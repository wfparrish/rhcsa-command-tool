[
  {
    "id": 1,
    "title": "Establish a local repository by mounting a RHEL-9 ISO on the /mnt directory.",
    "steps": [
      {
        "id": 1,
        "instruction": "Use the command to list block devices and identify the ISO device.",
        "answer": "lsblk",
        "explanation": "The `lsblk` (list block devices) command displays information about all available or the specified block devices. It helps identify the device name assigned to the mounted ISO, ensuring you mount the correct device."
      },
      {
        "id": 2,
        "instruction": "Use the command to find the UUID or LABEL of the ISO device.",
        "answer": "blkid",
        "explanation": "The `blkid` command is used to locate or print block device attributes such as UUID (Universally Unique Identifier) or LABEL. Identifying the UUID or LABEL of the ISO device ensures precise mounting, especially in environments where device names might change."
      },
      {
        "id": 3,
        "instruction": "Use the command to display filesystem usage, ensuring the ISO is properly mounted.",
        "answer": "df -h",
        "explanation": "The `df` (disk filesystem) command reports file system disk space usage. The `-h` flag stands for 'human-readable' format, displaying sizes in KB, MB, or GB. Running this command verifies that the ISO has been successfully mounted by showing its mount point and available space."
      },
      {
        "id": 4,
        "instruction": "Use the command to confirm that the ISO filesystem type is detected as 'iso9660'.",
        "answer": "mount | grep 'iso9660'",
        "explanation": "The `mount` command without arguments lists all mounted filesystems. Piping it to `grep 'iso9660'` filters the output to show only entries using the 'iso9660' filesystem type, which is standard for ISO images. This confirmation ensures that the ISO is mounted with the correct filesystem type."
      },
      {
        "id": 5,
        "instruction": "Use the command to search for the ISO file within the specified directory or device.",
        "answer": "find /dev/sr0 -type f -name \"<name of the iso>\"",
        "explanation": "The `find` command searches for files in a directory hierarchy. Here, it's used to locate the ISO file within the `/dev/sr0` device directory by specifying the file type as `f` (regular file) and matching the ISO file name. This step ensures that the correct ISO file is identified for mounting."
      },
      {
        "id": 6,
        "instruction": "Create a directory to use as the mount point for the ISO.",
        "answer": "mkdir /repo",
        "explanation": "The `mkdir` (make directory) command creates a new directory named `/repo`, which serves as the mount point for the ISO. Establishing a dedicated mount point helps organize the filesystem and ensures that the ISO is mounted in a predictable and accessible location."
      },
      {
        "id": 7,
        "instruction": "Add the ISO device to the '/etc/fstab' file to ensure it mounts on boot.",
        "answer": "echo \"/dev/sr0 /repo iso9660 loop 0 0\" >> /etc/fstab",
        "explanation": "This command appends a new entry to the `/etc/fstab` file, which configures filesystems to be mounted automatically at boot time. The entry specifies that the ISO device `/dev/sr0` should be mounted at `/repo` using the `iso9660` filesystem type. The `loop` option allows mounting a file as a filesystem, and the final two zeros (`0 0`) indicate that the filesystem should not be dumped or checked on boot."
      },
      {
        "id": 8,
        "instruction": "Mount all filesystems defined in the '/etc/fstab' file.",
        "answer": "mount -a",
        "explanation": "The `mount -a` command mounts all filesystems mentioned in the `/etc/fstab` file, except those marked with the `noauto` option. This ensures that the ISO is mounted immediately without needing a system reboot, adhering to the configurations set previously."
      },
      {
        "id": 9,
        "instruction": "Add the BaseOS repository from the mounted ISO to DNF configuration.",
        "answer": "dnf config-manager --add-repo=file:///repo/BaseOS",
        "explanation": "The `dnf config-manager` command manages DNF repository configurations. The `--add-repo` option adds a new repository by specifying its URL. Here, it adds the BaseOS repository from the mounted ISO located at `/repo/BaseOS`, enabling the system to install packages from this local source."
      },
      {
        "id": 10,
        "instruction": "Add the AppStream repository from the mounted ISO to DNF configuration.",
        "answer": "dnf config-manager --add-repo=file:///repo/AppStream",
        "explanation": "Similar to Step 9, this command adds the AppStream repository from the mounted ISO at `/repo/AppStream` to the DNF configuration. The AppStream repository contains additional packages and modules, expanding the range of software available for installation from the local repository."
      },
      {
        "id": 11,
        "instruction": "List all repository configuration files to verify the new repos are created.",
        "answer": "ls -l /etc/yum.repos.d/",
        "explanation": "The `ls -l` command lists detailed information about files in the `/etc/yum.repos.d/` directory, where DNF repository configuration files are stored. Verifying the presence of new `.repo` files confirms that the BaseOS and AppStream repositories have been successfully added."
      },
      {
        "id": 12,
        "instruction": "Disable GPG checking for the BaseOS repository by appending the appropriate configuration.",
        "answer": "echo \"gpgcheck=0\" | sudo tee -a /etc/yum.repos.d/repo_BaseOS.repo",
        "explanation": "This command disables GPG (GNU Privacy Guard) signature checking for the BaseOS repository by appending `gpgcheck=0` to its `.repo` file. Disabling GPG checks allows DNF to install packages without verifying their signatures, which can be useful in controlled environments but should be done with caution to maintain security."
      },
      {
        "id": 13,
        "instruction": "Disable GPG checking for the AppStream repository by appending the appropriate configuration.",
        "answer": "echo \"gpgcheck=0\" | sudo tee -a /etc/yum.repos.d/repo_AppStream.repo",
        "explanation": "Similar to Step 12, this command disables GPG signature checking for the AppStream repository by adding `gpgcheck=0` to its `.repo` file. This ensures that packages from the AppStream repository can be installed without signature verification."
      },
      {
        "id": 14,
        "instruction": "List all available repositories to confirm the BaseOS and AppStream repositories are active.",
        "answer": "dnf repolist",
        "explanation": "The `dnf repolist` command lists all enabled DNF repositories. Running this command verifies that the newly added BaseOS and AppStream repositories are active and available for package installations."
      },
      {
        "id": 15,
        "instruction": "Open the '/etc/fstab' file in an editor to remove entries causing issues.",
        "answer": "sudo vim /etc/fstab",
        "explanation": "The `vim` editor is used here to open the `/etc/fstab` file with superuser privileges (`sudo`). Editing this file allows you to remove or modify filesystem mount entries that may be causing boot or mounting issues, ensuring system stability."
      },
      {
        "id": 16,
        "instruction": "Delete the problematic line from the '/etc/fstab' file.",
        "answer": "dd",
        "explanation": "In the `vim` editor, the `dd` command deletes the current line where the cursor is positioned. This is used to remove the faulty mount entry from `/etc/fstab`, preventing potential boot problems related to incorrect filesystem mounts."
      },
      {
        "id": 17,
        "instruction": "Save and exit the '/etc/fstab' file.",
        "answer": ":wq",
        "explanation": "The `:wq` command in `vim` writes (saves) the changes made to the file and quits the editor. This finalizes the removal of the problematic entry from `/etc/fstab`, ensuring that the system no longer attempts to mount the faulty filesystem on boot."
      },
      {
        "id": 18,
        "instruction": "Unmount the ISO from the '/repo' directory.",
        "answer": "umount /repo",
        "explanation": "The `umount` command detaches the filesystem mounted at `/repo`. Unmounting the ISO ensures that resources are freed and the mount point is clean, especially after removing the corresponding entry from `/etc/fstab`."
      },
      {
        "id": 19,
        "instruction": "Remove the '/repo' directory to clean up the mount point.",
        "answer": "rmdir /repo",
        "explanation": "The `rmdir` (remove directory) command deletes the `/repo` directory. Cleaning up the mount point by removing the directory helps maintain an organized filesystem and prevents clutter from unused mount points."
      },
      {
        "id": 20,
        "instruction": "List all repository configuration files to locate and identify the files to remove.",
        "answer": "ls /etc/yum.repos.d/",
        "explanation": "The `ls` command lists the contents of the `/etc/yum.repos.d/` directory, where DNF repository configuration files are stored. Reviewing these files helps identify which repository configurations need to be removed or modified to reset the DNF configuration."
      },
      {
        "id": 21,
        "instruction": "Remove the repository configuration files to reset the DNF configuration.",
        "answer": "rm <name of the files>.repo",
        "explanation": "The `rm` (remove) command deletes specified `.repo` files from `/etc/yum.repos.d/`. Removing these repository configuration files resets DNF to its default state, eliminating any custom or problematic repository settings that were previously added."
      }
    ]
  },
  {
    "id": 2,
    "title": "Create a new user and group.",
    "steps": [
      {
        "id": 1,
        "instruction": "Create a user named 'student'.",
        "answer": "useradd student"
      },
      {
        "id": 2,
        "instruction": "Create a group named 'developers'.",
        "answer": "groupadd developers"
      },
      {
        "id": 3,
        "instruction": "Add 'student' to the 'developers' group.",
        "answer": "usermod -aG developers student"
      }
    ]
  },
  {
    "id": 3,
    "title": "Assume that you forget the root password. Reset the root password for ServerB. Change it to “secret” to gain access to the system.",
    "steps": [
      {
        "id": 1,
        "instruction": "Reboot the server to start the reset process.",
        "answer": "reboot"
      },
      {
        "id": 2,
        "instruction": "During boot, press the appropriate key to enter the boot menu.",
        "answer": "F8"
      },
      {
        "id": 3,
        "instruction": "In the boot menu, edit the kernel boot parameters by pressing the designated key.",
        "answer": "e"
      },
      {
        "id": 4,
        "instruction": "Navigate to the kernel boot parameters and modify them to boot into a minimal shell environment.",
        "answer": "Ctrl-e"
      },
      {
        "id": 5,
        "instruction": "Exit the boot menu and boot with the modified parameters.",
        "answer": "Ctrl-x"
      },
      {
        "id": 6,
        "instruction": "At the bash prompt, remount the root filesystem as read-write to allow changes.",
        "answer": "mount -o remount,rw /"
      },
      {
        "id": 7,
        "instruction": "Change the root password using the appropriate command.",
        "answer": "passwd"
      },
      {
        "id": 8,
        "instruction": "Set the new password as 'secret' when prompted.",
        "answer": "secret"
      },
      {
        "id": 9,
        "instruction": "Ensure the correct SELinux context is applied to the shadow file.",
        "answer": "chcon system_u:object_r:shadow_t:s0 /etc/shadow"
      },
      {
        "id": 10,
        "instruction": "Start the init process to fully boot the system.",
        "answer": "exec /sbin/init"
      }
    ]
  },
  {
    "id": 4,
    "title": "Create a NetworkManager connection profile named 'myprofile1' for the enp0s3 device with the given settings. Ensure the connection is running and add secondary IPv4 and IPv6 addresses to the profile.",
    "steps": [
      {
        "id": 1,
        "instruction": "Display the current network interfaces to verify the existence of the 'enp0s3' device.",
        "answer": "ip link show"
      },
      {
        "id": 2,
        "instruction": "Add a new NetworkManager connection profile named 'myprofile1' for the 'enp0s3' device.",
        "answer": "nmcli con add type ethernet con-name myprofile1 ifname enp0s3"
      },
      {
        "id": 3,
        "instruction": "Set the primary IPv4 address for the 'myprofile1' connection profile.",
        "answer": "nmcli con mod myprofile1 ipv4.addresses 172.16.127.101/24"
      },
      {
        "id": 4,
        "instruction": "Set the gateway for the IPv4 address in the 'myprofile1' connection profile.",
        "answer": "nmcli con mod myprofile1 ipv4.gateway 172.16.127.100"
      },
      {
        "id": 5,
        "instruction": "Set the DNS servers for the IPv4 address in the 'myprofile1' connection profile.",
        "answer": "nmcli con mod myprofile1 ipv4.dns \"8.8.8.8 8.8.4.4\""
      },
      {
        "id": 6,
        "instruction": "Set the DNS search domain for the IPv4 address in the 'myprofile1' connection profile.",
        "answer": "nmcli con mod myprofile1 ipv4.dns-search \"example.com\""
      },
      {
        "id": 7,
        "instruction": "Set the primary IPv6 address for the 'myprofile1' connection profile.",
        "answer": "nmcli con mod myprofile1 ipv6.addresses fd01::0:101/64"
      },
      {
        "id": 8,
        "instruction": "Set the gateway for the IPv6 address in the 'myprofile1' connection profile.",
        "answer": "nmcli con mod myprofile1 ipv6.gateway fd01::0:100"
      },
      {
        "id": 9,
        "instruction": "Set the DNS server for the IPv6 address in the 'myprofile1' connection profile.",
        "answer": "nmcli con mod myprofile1 ipv6.dns fd01::0:111"
      },
      {
        "id": 10,
        "instruction": "Set the DNS search domain for the IPv6 address in the 'myprofile1' connection profile.",
        "answer": "nmcli con mod myprofile1 ipv6.dns-search \"example.com\""
      },
      {
        "id": 11,
        "instruction": "Add a secondary IPv4 address to the 'myprofile1' connection profile.",
        "answer": "nmcli con mod myprofile1 +ipv4.addresses 172.16.127.102/24"
      },
      {
        "id": 12,
        "instruction": "Add a secondary IPv6 address to the 'myprofile1' connection profile.",
        "answer": "nmcli con mod myprofile1 +ipv6.addresses fd01::0:102/64"
      },
      {
        "id": 13,
        "instruction": "Bring up the 'myprofile1' connection to ensure it is active and running.",
        "answer": "nmcli con up myprofile1"
      }
    ]
  },
  {
    "id": 5,
    "title": "On ServerA, configure a Local Yum/DNF Repository using the RHEL-9 ISO image mounted on the /repo directory. Additionally, set up an HTTP server to allow client machines to access the repository via HTTP. Ensure the repository includes both the BaseOS and AppStream directories and is accessible without an internet connection.\n\nOnce the HTTP server is configured, prepare the client machines to use the HTTP server as their repository source. Test the setup by verifying the repository configuration and availability on the client machines.",
    "steps": [
      {
        "id": 1,
        "instruction": "Create a directory to serve as the mount point for the RHEL-9 ISO.",
        "answer": "mkdir /repo"
      },
      {
        "id": 2,
        "instruction": "Add the ISO device to '/etc/fstab' to ensure it mounts persistently on reboot.",
        "answer": "echo \"/dev/sr0 /repo iso9660 loop 0 0\" >> /etc/fstab"
      },
      {
        "id": 3,
        "instruction": "Mount all filesystems defined in '/etc/fstab' to mount the ISO.",
        "answer": "mount -a"
      },
      {
        "id": 4,
        "instruction": "Configure DNF to use the 'BaseOS' directory from the mounted ISO.",
        "answer": "dnf config-manager --add-repo=file:///repo/BaseOS"
      },
      {
        "id": 5,
        "instruction": "Configure DNF to use the 'AppStream' directory from the mounted ISO.",
        "answer": "dnf config-manager --add-repo=file:///repo/AppStream"
      },
      {
        "id": 6,
        "instruction": "Verify the repository configuration files in '/etc/yum.repos.d/'.",
        "answer": "ls -l /etc/yum.repos.d/"
      },
      {
        "id": 7,
        "instruction": "Disable GPG signature checking for the 'BaseOS' repository.",
        "answer": "echo \"gpgcheck=0\" | sudo tee -a /etc/yum.repos.d/repo_BaseOS.repo"
      },
      {
        "id": 8,
        "instruction": "Disable GPG signature checking for the 'AppStream' repository.",
        "answer": "echo \"gpgcheck=0\" | sudo tee -a /etc/yum.repos.d/repo_AppStream.repo"
      },
      {
        "id": 9,
        "instruction": "Install the HTTP server package.",
        "answer": "sudo dnf install httpd"
      },
      {
        "id": 10,
        "instruction": "Start the HTTP server.",
        "answer": "sudo systemctl start httpd"
      },
      {
        "id": 11,
        "instruction": "Enable the HTTP server to start on boot.",
        "answer": "sudo systemctl enable httpd"
      },
      {
        "id": 12,
        "instruction": "Create a symbolic link in the web server directory for 'BaseOS'.",
        "answer": "sudo ln -s /repo/BaseOS /var/www/html/BaseOS"
      },
      {
        "id": 13,
        "instruction": "Create a symbolic link in the web server directory for 'AppStream'.",
        "answer": "sudo ln -s /repo/AppStream /var/www/html/AppStream"
      }
    ]
  },
  {
    "id": 6,
    "title": "On the client machines, configure the repositories to use the HTTP server on ServerA. Test the setup by verifying that the repositories are correctly configured and available.",
    "steps": [
      {
        "id": 1,
        "instruction": "Create the repository file for the BaseOS repository.",
        "answer": "sudo vi /etc/yum.repos.d/local_BaseOS.repo"
      },
      {
        "id": 2,
        "instruction": "Add the repository ID for the BaseOS repository.",
        "answer": "[local-baseos]"
      },
      {
        "id": 3,
        "instruction": "Set the name for the BaseOS repository.",
        "answer": "name=Local BaseOS Repository"
      },
      {
        "id": 4,
        "instruction": "Specify the base URL for the BaseOS repository (replace 'your-server-ip' with the server's IP address).",
        "answer": "baseurl=http://your-server-ip/BaseOS"
      },
      {
        "id": 5,
        "instruction": "Enable the BaseOS repository.",
        "answer": "enabled=1"
      },
      {
        "id": 6,
        "instruction": "Disable GPG signature verification for the BaseOS repository.",
        "answer": "gpgcheck=0"
      },
      {
        "id": 7,
        "instruction": "Save and exit the repository file.",
        "answer": ":wq"
      },
      {
        "id": 8,
        "instruction": "Create the repository file for the AppStream repository.",
        "answer": "sudo vi /etc/yum.repos.d/local_AppStream.repo"
      },
      {
        "id": 9,
        "instruction": "Add the repository ID for the AppStream repository.",
        "answer": "[local-appstream]"
      },
      {
        "id": 10,
        "instruction": "Set the name for the AppStream repository.",
        "answer": "name=Local AppStream Repository"
      },
      {
        "id": 11,
        "instruction": "Specify the base URL for the AppStream repository (replace 'your-server-ip' with the server's IP address).",
        "answer": "baseurl=http://your-server-ip/AppStream"
      },
      {
        "id": 12,
        "instruction": "Enable the AppStream repository.",
        "answer": "enabled=1"
      },
      {
        "id": 13,
        "instruction": "Disable GPG signature verification for the AppStream repository.",
        "answer": "gpgcheck=0"
      },
      {
        "id": 14,
        "instruction": "Save and exit the repository file.",
        "answer": ":wq"
      },
      {
        "id": 15,
        "instruction": "Clean the DNF cache to ensure the new repositories are recognized.",
        "answer": "sudo dnf clean all"
      },
      {
        "id": 16,
        "instruction": "Verify that the repositories are correctly configured and available.",
        "answer": "sudo dnf repolist"
      }
    ]
  },{
    "id": 7,
    "title": "On ServerA, configure the system time to the 'America/New_York' timezone.",
    "steps": [
      {
        "id": 1,
        "instruction": "View the current system time and timezone configuration.",
        "answer": "timedatectl"
      },
      {
        "id": 2,
        "instruction": "List all available timezones to find the desired timezone.",
        "answer": "timedatectl list-timezones"
      },
      {
        "id": 3,
        "instruction": "Search for the 'America/New_York' timezone using grep.",
        "answer": "timedatectl list-timezones | grep -o 'America/Ne.*'"
      },
      {
        "id": 4,
        "instruction": "Set the system timezone to 'America/New_York'.",
        "answer": "timedatectl set-timezone 'America/New_York'"
      },
      {
        "id": 5,
        "instruction": "Verify that the timezone has been set to 'America/New_York'.",
        "answer": "timedatectl"
      }
    ]
  },{
    "id": 8,
    "title": "Configure Time Synchronization and Timezone Using Chrony.",
    "steps": [
      {
        "id": 1,
        "instruction": "Install the chrony package to manage time synchronization.",
        "answer": "sudo dnf install chrony"
      },
      {
        "id": 2,
        "instruction": "Verify that the chrony package is installed.",
        "answer": "sudo dnf list installed chrony"
      },
      {
        "id": 3,
        "instruction": "Enable the chronyd service to start at boot.",
        "answer": "sudo systemctl enable chronyd"
      },
      {
        "id": 4,
        "instruction": "Start the chronyd service to begin time synchronization immediately.",
        "answer": "sudo systemctl start chronyd"
      },
      {
        "id": 5,
        "instruction": "Verify the current time synchronization status.",
        "answer": "chronyc tracking"
      },
      {
        "id": 6,
        "instruction": "Check the current time sources used by chronyd.",
        "answer": "chronyc sources -v"
      },
      {
        "id": 7,
        "instruction": "Open the /etc/chrony.conf file for editing to specify NTP servers.",
        "answer": "sudo vim /etc/chrony.conf"
      },
      {
        "id": 8,
        "instruction": "Add a preferred NTP server configuration to the /etc/chrony.conf file.",
        "answer": "server time1.example.com iburst"
      },
      {
        "id": 9,
        "instruction": "Add a second preferred NTP server configuration to the /etc/chrony.conf file.",
        "answer": "server time2.example.com iburst"
      },
      {
        "id": 10,
        "instruction": "Configure the firewall to allow NTP traffic through.",
        "answer": "sudo firewall-cmd --add-service=ntp --permanent"
      },
      {
        "id": 11,
        "instruction": "Reload the firewall to apply the changes for NTP traffic.",
        "answer": "sudo firewall-cmd --reload"
      },
      {
        "id": 12,
        "instruction": "Force an immediate synchronization of the system clock with NTP servers.",
        "answer": "sudo chronyc -a makestep"
      },
      {
        "id": 13,
        "instruction": "Set the system timezone to 'America/New_York'.",
        "answer": "sudo timedatectl set-timezone America/New_York"
      },
      {
        "id": 14,
        "instruction": "Verify the current time and timezone configuration.",
        "answer": "timedatectl"
      }
    ]
  },{
    "id": 9,
    "title": "On ServerA, add a new disk, create a 2GiB partition on /dev/sdb, and use it to create a volume group named 'myvg'.",
    "steps": [
      {
        "id": 1,
        "instruction": "List all available block devices to verify the current disk configuration.",
        "answer": "lsblk"
      },
      {
        "id": 2,
        "instruction": "Shut down the virtual machine to add a new disk.",
        "answer": "shutdown now"
      },
      {
        "id": 3,
        "instruction": "Add a new SATA disk to the system using your hypervisor or environment's disk addition process.",
        "answer": "Add a new SATA disk."
      },
      {
        "id": 4,
        "instruction": "Attach the newly added disk to the virtual machine or server.",
        "answer": "Attach the new disk to the VM or server."
      },
      {
        "id": 5,
        "instruction": "Start the virtual machine and verify that the new disk appears as 'sdb'.",
        "answer": "lsblk"
      },
      {
        "id": 6,
        "instruction": "Open the /dev/sdb disk in the fdisk utility to partition it.",
        "answer": "fdisk /dev/sdb"
      },
      {
        "id": 7,
        "instruction": "Create a new partition by selecting the 'new partition' option in fdisk.",
        "answer": "n"
      },
      {
        "id": 8,
        "instruction": "Specify the partition type as 'primary'.",
        "answer": "p"
      },
      {
        "id": 9,
        "instruction": "Enter the partition number for the new partition (e.g., 1).",
        "answer": "1"
      },
      {
        "id": 10,
        "instruction": "Press Enter to confirm the default first sector.",
        "answer": "Press Enter"
      },
      {
        "id": 11,
        "instruction": "Specify the last sector to create a 2GiB partition.",
        "answer": "+2GiB"
      },
      {
        "id": 12,
        "instruction": "Change the partition type by selecting the appropriate fdisk option.",
        "answer": "t"
      },
      {
        "id": 13,
        "instruction": "Enter the hex code for 'Linux LVM' partition type.",
        "answer": "8e"
      },
      {
        "id": 14,
        "instruction": "Display the partition table to confirm the updated partition type.",
        "answer": "p"
      },
      {
        "id": 15,
        "instruction": "Write the changes to the disk and exit fdisk.",
        "answer": "w"
      },
      {
        "id": 16,
        "instruction": "Verify the new partition table to ensure the partition was created.",
        "answer": "fdisk -l"
      },
      {
        "id": 17,
        "instruction": "Initialize the /dev/sdb1 physical volume for use by LVM.",
        "answer": "pvcreate /dev/sdb1"
      },
      {
        "id": 18,
        "instruction": "Display information about configured physical volumes.",
        "answer": "pvs"
      },
      {
        "id": 19,
        "instruction": "Create a volume group named 'myvg' using /dev/sdb1.",
        "answer": "vgcreate myvg /dev/sdb1"
      },
      {
        "id": 20,
        "instruction": "Verify that the volume group 'myvg' has been created.",
        "answer": "vgs"
      }
    ]
  },{
    "id": 10,
    "title": "On ServerA, create a 500MiB logical volume named 'mylv' within the 'myvg' volume group on /dev/sdb.",
    "steps": [
      {
        "id": 1,
        "instruction": "Display information about the existing volume groups to confirm 'myvg' exists.",
        "answer": "vgs"
      },
      {
        "id": 2,
        "instruction": "Create a logical volume named 'mylv' with a size of 500MiB in the 'myvg' volume group.",
        "answer": "lvcreate -n mylv -L 500MiB myvg"
      },
      {
        "id": 3,
        "instruction": "Verify that the logical volume 'mylv' has been created successfully.",
        "answer": "lvs"
      },
      {
        "id": 4,
        "instruction": "Recheck the volume group to ensure it reflects the new logical volume.",
        "answer": "vgs"
      }
    ]
  },{
    "id": 11,
    "title": "On ServerA, format the 'mylv' logical volume with the ext4 filesystem and mount it persistently on the /mylv directory.",
    "steps": [
      {
        "id": 1,
        "instruction": "Display information about the logical volumes to confirm 'mylv' exists.",
        "answer": "lvs"
      },
      {
        "id": 2,
        "instruction": "Create an ext4 filesystem on the 'mylv' logical volume.",
        "answer": "mkfs.ext4 /dev/mapper/myvg-mylv"
      },
      {
        "id": 3,
        "instruction": "Create a directory named '/mylv' to serve as the mount point.",
        "answer": "mkdir /mylv"
      },
      {
        "id": 4,
        "instruction": "Open the '/etc/fstab' file for editing using Vim.",
        "answer": "vim /etc/fstab"
      },
      {
        "id": 5,
        "instruction": "Navigate to the last line in the file and insert a new line below it.",
        "answer": "Press Shift + G, then press o"
      },
      {
        "id": 6,
        "instruction": "Add the following entry to mount 'mylv' persistently:\n/dev/mapper/myvg-mylv /mylv ext4 defaults 0 0",
        "answer": "/dev/mapper/myvg-mylv /mylv ext4 defaults 0 0"
      },
      {
        "id": 7,
        "instruction": "Save and exit the Vim editor.",
        "answer": "Press Esc, then type :wq and press Enter"
      },
      {
        "id": 8,
        "instruction": "Mount all file systems specified in '/etc/fstab' to ensure the changes take effect.",
        "answer": "mount -a"
      },
      {
        "id": 9,
        "instruction": "List all available block devices to confirm '/mylv' is mounted correctly.",
        "answer": "lsblk"
      }
    ]
  },{
    "id": 12,
    "title": "On ServerA, extend the ext4 filesystem on 'mylv' by 500MiB.",
    "steps": [
      {
        "id": 1,
        "instruction": "Display information about the volume groups to confirm sufficient space is available.",
        "answer": "vgs"
      },
      {
        "id": 2,
        "instruction": "Extend the logical volume 'myvg-mylv' by 500MiB and resize the filesystem to match the new size.",
        "answer": "lvextend -r -L +500M /dev/mapper/myvg-mylv"
      },
      {
        "id": 3,
        "instruction": "Verify that the logical volume 'myvg-mylv' has been extended successfully.",
        "answer": "lvs"
      }
    ]
  },{
    "id": 13,
    "title": "On ServerA, configure a basic web server that displays 'Welcome to the webserver!' and ensure the firewall allows HTTP/HTTPS services.",
    "steps": [
      {
        "id": 1,
        "instruction": "Install the Apache web server.",
        "answer": "dnf install httpd -y"
      },
      {
        "id": 2,
        "instruction": "Enable the Apache service to start automatically at boot.",
        "answer": "systemctl enable httpd"
      },
      {
        "id": 3,
        "instruction": "Start the Apache service.",
        "answer": "systemctl start httpd"
      },
      {
        "id": 4,
        "instruction": "Check the status of the Apache service to ensure it is running.",
        "answer": "systemctl status httpd"
      },
      {
        "id": 5,
        "instruction": "Open the 'index.html' file in the '/var/www/html/' directory using Vim.",
        "answer": "vim /var/www/html/index.html"
      },
      {
        "id": 6,
        "instruction": "Add the text 'Welcome to the webserver!' to the 'index.html' file.",
        "answer": "Enter: Welcome to the webserver!"
      },
      {
        "id": 7,
        "instruction": "Save and exit the Vim editor.",
        "answer": "Press Esc, then type :wq and press Enter"
      },
      {
        "id": 8,
        "instruction": "Restart the Apache service to apply changes.",
        "answer": "systemctl restart httpd"
      },
      {
        "id": 9,
        "instruction": "Display a list of all the active zones and their associated firewall rules in the firewalld service.",
        "answer": "firewall-cmd --list-all"
      },
      {
        "id": 10,
        "instruction": "List all the available services in the firewall.",
        "answer": "firewall-cmd --get-services"
      },
      {
        "id": 11,
        "instruction": "Add a permanent firewall rule to allow incoming HTTP traffic.",
        "answer": "firewall-cmd --zone=public --add-service=http --permanent"
      },
      {
        "id": 12,
        "instruction": "Add a permanent firewall rule to allow incoming HTTPS traffic.",
        "answer": "firewall-cmd --zone=public --add-service=https --permanent"
      },
      {
        "id": 13,
        "instruction": "Reload the firewall configuration to apply the changes.",
        "answer": "firewall-cmd --reload"
      },
      {
        "id": 14,
        "instruction": "Verify the active firewall rules to confirm HTTP and HTTPS traffic are allowed.",
        "answer": "firewall-cmd --list-all"
      },
      {
        "id": 15,
        "instruction": "Perform a simple HTTP request to the web server running on the local machine to confirm it is working.",
        "answer": "curl http://localhost"
      }
    ]
  },{
    "id": 14,
    "title": "On ServerA, find all files larger than 3MB in the '/etc' directory and copy them to '/find/3mfiles'.",
    "steps": [
      {
        "id": 1,
        "instruction": "Create the '/find/3mfiles' directory, including any necessary parent directories.",
        "answer": "mkdir -p /find/3mfiles"
      },
      {
        "id": 2,
        "instruction": "Find all files in the '/etc' directory that are larger than 3MB and copy them to '/find/3mfiles'.",
        "answer": "find /etc -size +3M -exec cp {} /find/3mfiles/ \\;"
      },
      {
        "id": 3,
        "instruction": "List the files in '/find/3mfiles' in long format to verify the copied files.",
        "answer": "ll /find/3mfiles"
      }
    ]
  },{
    "id": 15,
    "title": "On ServerA, ensure that boot messages are present (not silenced).",
    "steps": [
      {
        "id": 1,
        "instruction": "Open the GRUB configuration file using Vim.",
        "answer": "vim /etc/default/grub"
      },
      {
        "id": 2,
        "instruction": "Locate the line beginning with 'GRUB_CMDLINE_LINUX' and remove 'rhgb quiet' from the line.",
        "answer": "Remove: rhgb quiet"
      },
      {
        "id": 3,
        "instruction": "Save and exit the Vim editor.",
        "answer": "Press Esc, then type :wq and press Enter"
      },
      {
        "id": 4,
        "instruction": "Generate a new GRUB configuration file to apply the changes.",
        "answer": "grub2-mkconfig -o /boot/grub2/grub.cfg"
      },
      {
        "id": 5,
        "instruction": "Reboot the system to apply the new GRUB configuration.",
        "answer": "systemctl reboot"
      }
    ]
  },{
    "id": 16,
    "title": "On ServerA, create users and groups, then configure access to '/admins' and '/developers' directories.",
    "steps": [
      {
        "id": 1,
        "instruction": "Create the 'admins' group if it does not already exist.",
        "answer": "groupadd admins"
      },
      {
        "id": 2,
        "instruction": "Create the 'developers' group if it does not already exist.",
        "answer": "groupadd developers"
      },
      {
        "id": 3,
        "instruction": "Create the user 'amr'.",
        "answer": "useradd amr"
      },
      {
        "id": 4,
        "instruction": "Create the user 'biko'.",
        "answer": "useradd biko"
      },
      {
        "id": 5,
        "instruction": "Create the user 'carlos'.",
        "answer": "useradd carlos"
      },
      {
        "id": 6,
        "instruction": "Create the user 'david'.",
        "answer": "useradd david"
      },
      {
        "id": 7,
        "instruction": "Add the user 'amr' to the 'admins' group as a secondary group.",
        "answer": "usermod -aG admins amr"
      },
      {
        "id": 8,
        "instruction": "Add the user 'biko' to the 'admins' group as a secondary group.",
        "answer": "usermod -aG admins biko"
      },
      {
        "id": 9,
        "instruction": "Add the user 'carlos' to the 'developers' group as a secondary group.",
        "answer": "usermod -aG developers carlos"
      },
      {
        "id": 10,
        "instruction": "Add the user 'david' to the 'developers' group as a secondary group.",
        "answer": "usermod -aG developers david"
      },
      {
        "id": 11,
        "instruction": "Create the '/admins' directory.",
        "answer": "mkdir /admins"
      },
      {
        "id": 12,
        "instruction": "Create the '/developers' directory.",
        "answer": "mkdir /developers"
      },
      {
        "id": 13,
        "instruction": "Set the ownership of the '/admins' directory to the user 'biko' and the group 'admins'.",
        "answer": "chown biko:admins /admins"
      },
      {
        "id": 14,
        "instruction": "Set the ownership of the '/developers' directory to the user 'carlos' and the group 'developers'.",
        "answer": "chown carlos:developers /developers"
      },
      {
        "id": 15,
        "instruction": "Set the permissions of the '/admins' directory so only the owner and group members have access.",
        "answer": "chmod 770 /admins"
      },
      {
        "id": 16,
        "instruction": "Set the permissions of the '/developers' directory so only the owner and group members have access.",
        "answer": "chmod 770 /developers"
      },
      {
        "id": 17,
        "instruction": "Set the SGID (Set Group ID) bit on the '/admins' directory to ensure new files inherit the group owner.",
        "answer": "chmod g+s /admins"
      },
      {
        "id": 18,
        "instruction": "Set the SGID (Set Group ID) bit on the '/developers' directory to ensure new files inherit the group owner.",
        "answer": "chmod g+s /developers"
      },
      {
        "id": 19,
        "instruction": "Prevent users other than the file creator from deleting files in the '/admins' directory by setting the sticky bit.",
        "answer": "chmod +t /admins"
      },
      {
        "id": 20,
        "instruction": "Prevent users other than the file creator from deleting files in the '/developers' directory by setting the sticky bit.",
        "answer": "chmod +t /developers"
      },
      {
        "id": 21,
        "instruction": "Verify the ownership, permissions, SGID, and sticky bit on the '/admins' directory.",
        "answer": "ls -ld /admins"
      },
      {
        "id": 22,
        "instruction": "Verify the ownership, permissions, SGID, and sticky bit on the '/developers' directory.",
        "answer": "ls -ld /developers"
      }
    ]
  },{
    "id": 17,
    "title": "On ServerA, create a 200MB swap partition on /dev/sdb and ensure it takes effect automatically at boot.",
    "steps": [
      {
        "id": 1,
        "instruction": "Display the current amount of free and used memory in the system, in megabytes.",
        "answer": "free -m"
      },
      {
        "id": 2,
        "instruction": "Open the interactive command-line mode of the fdisk utility to create a new partition on /dev/sdb.",
        "answer": "fdisk /dev/sdb"
      },
      {
        "id": 3,
        "instruction": "Enter the correct value in fdisk to display available options.",
        "answer": "m"
      },
      {
        "id": 4,
        "instruction": "Enter the correct value to create a new partition.",
        "answer": "n"
      },
      {
        "id": 5,
        "instruction": "Select the correct value to create a primary partition.",
        "answer": "p"
      },
      {
        "id": 6,
        "instruction": "Specify the partition number as '2' or press this key to accept the default.",
        "answer": "2 or Enter"
      },
      {
        "id": 7,
        "instruction": "Press this key to confirm the default first sector.",
        "answer": "Enter"
      },
      {
        "id": 8,
        "instruction": "Specify the partition size as 200MB by entering the correct value",
        "answer": "+200M"
      },
      {
        "id": 9,
        "instruction": "Enter the correct value to print the current partition table and verify the new partition.",
        "answer": "p"
      },
      {
        "id": 10,
        "instruction": "Enter the correct value to change the partition type.",
        "answer": "t"
      },
      {
        "id": 11,
        "instruction": "Specify the partition number and press Enter.",
        "answer": "2"
      },
      {
        "id": 12,
        "instruction": "Enter the correct value to list known partition types in fdisk.",
        "answer": "l"
      },
      {
        "id": 13,
        "instruction": "Set the partition type to Linux Swap by entering the correct value.",
        "answer": "82"
      },
      {
        "id": 14,
        "instruction": "Enter the correct value to print the updated partition table and confirm the changes.",
        "answer": "p"
      },
      {
        "id": 15,
        "instruction": "Enter the correct value to write the changes to the disk and exit fdisk.",
        "answer": "w"
      },
      {
        "id": 16,
        "instruction": "Inform the kernel of the changes made to the partition table without rebooting.",
        "answer": "partprobe"
      },
      {
        "id": 17,
        "instruction": "List all available block devices to verify the new partition.",
        "answer": "lsblk"
      },
      {
        "id": 18,
        "instruction": "Format the new partition as a swap partition.",
        "answer": "mkswap /dev/sdb2"
      },
      {
        "id": 19,
        "instruction": "Display the UUID of '/dev/sdb2' to use for persistent configuration.",
        "answer": "blkid"
      },
      {
        "id": 20,
        "instruction": "Open the '/etc/fstab' file using Vim to configure the new swap partition for automatic use at boot.",
        "answer": "vim /etc/fstab"
      },
      {
        "id": 21,
        "instruction": "Add the line to the file to enable the new swap partition: ",
        "answer": "UUID=<id listed for /dev/sdb2 in the blkid output> swap swap defaults 0 0"
      },
      {
        "id": 22,
        "instruction": "Save and exit Vim.",
        "answer": "Press Esc, then type :wq and press Enter"
      },
      {
        "id": 23,
        "instruction": "Mount all filesystems specified in '/etc/fstab' to activate the new configuration.",
        "answer": "mount -a"
      },
      {
        "id": 24,
        "instruction": "Enable the new swap partition.",
        "answer": "swapon /dev/sdb2"
      },
      {
        "id": 25,
        "instruction": "Display the updated amount of free and used memory to confirm the new swap partition is active.",
        "answer": "free -m"
      },
      {
        "id": 26,
        "instruction": "List all available block devices to confirm the setup.",
        "answer": "lsblk"
      }
    ]
  },{
    "id": 18,
    "title": "Perform directory management tasks.",
    "steps": [
      {
        "id": 1,
        "instruction": "Display the current working directory.",
        "answer": "pwd"
      },
      {
        "id": 2,
        "instruction": "Check if a directory named 'TestDir' exists. If not, create it.",
        "answer": "[[ ! -d TestDir ]] && mkdir TestDir"
      },
      {
        "id": 3,
        "instruction": "Navigate into the 'TestDir' directory using the `cd` command.",
        "answer": "cd TestDir"
      },
      {
        "id": 4,
        "instruction": "Print the new current directory.",
        "answer": "pwd"
      },
      {
        "id": 5,
        "instruction": "Navigate back to the original directory using the `cd` command.",
        "answer": "cd -"
      }
    ]
  },{
    "id": 19,
    "title": "Demonstrate standard output, error, and combined redirection.",
    "steps": [
      {
        "id": 1,
        "instruction": "List all files in the current directory and redirect the output to a file named 'output.txt', appending to the file if it already exists.",
        "answer": "ls >> output.txt"
      },
      {
        "id": 2,
        "instruction": "Attempt to read a non-existent file and redirect the error message to a file named 'error.txt', appending to the file if it already exists.",
        "answer": "cat non_existent_file 2>> error.txt"
      },
      {
        "id": 3,
        "instruction": "Run a command that prints 'This is a message' to standard output and generates an error when you try to read from a file that doesn't exist. Redirect both standard output and the error from reading a non-existent file to a file named combined_output.txt, appending to the file if it already exists.",
        "answer": "echo \"This is a message\" && cat non_existent_file >> combined_output.txt 2>&1"
      }
    ]
  },{
    "id": 20,
    "title": "Given this file: sample.log 2024-08-10 12:00:00 INFO Starting application 2024-08-10 12:01:00 ERROR Failed to connect to database 2024-08-10 12:02:00 WARN Disk space running low 2024-08-10 12:03:00 INFO User login successful 2024-08-10 2:04:00 ERROR Unexpected error occurred Analyze logs from 'sample.log' to extract, filter, and count log entries based on specific criteria.",
    "steps": [
      {
        "id": 1,
        "instruction": "Extract all lines in 'sample.log' that contain the word 'ERROR' and save them to 'errors.log'.",
        "answer": "grep 'ERROR' sample.log > errors.log"
      },
      {
        "id": 2,
        "instruction": "Extract all lines with a timestamp of '2024-08-10' and a log level of 'INFO', and save them to 'info_logs.log'.",
        "answer": "grep -E '^2024-08-10.*INFO' sample.log > info_logs.log"
      },
      {
        "id": 3,
        "instruction": "Count the number of lines in 'sample.log' that contain the word 'Disk' and print the count to the terminal.",
        "answer": "grep -c 'Disk' sample.log"
      },
      {
        "id": 4,
        "instruction": "Extract all lines with a log level of 'WARN' and a message that starts with 'Disk', and save them to 'warn_disk_logs.log'.",
        "answer": "grep -E 'WARN Disk.*' sample.log > warn_disk_logs.log"
      }
    ]
  },{
    "id": 21,
    "title": "On ServerA, establish secure SSH access with user-provided credentials, validate inputs, and handle connection errors.",
    "steps": [
      {
        "id": 1,
        "instruction": "Create a prompt in the bash terminal that outputs 'Enter remote host: ' and uses a variable named remote_host to store user input.",
        "answer": "read -p 'Enter remote host: ' remote_host"
      },
      {
        "id": 2,
        "instruction": "Create a prompt in the bash terminal that outputs 'Enter SSH port (default is 22): ' and uses a variable named ssh_port to store user input.",
        "answer": "read -p 'Enter SSH port (default is 22): ' ssh_port"
      },
      {
        "id": 3,
        "instruction": "Create a prompt in the bash terminal that outputs 'Enter username: ' and uses a variable named ssh_user to store user input.",
        "answer": "read -p 'Enter username: ' ssh_user"
      },
      {
        "id": 4,
        "instruction": "Create a prompt in the bash terminal that outputs 'Enter private key path (leave empty if not using a key): ' and uses a variable named private_key to store user input.",
        "answer": "read -p 'Enter private key path (leave empty if not using a key): ' private_key"
      },
      {
        "id": 5,
        "instruction": "Validate that the remote_host variable is not empty and matches a valid hostname or IP address format.",
        "answer": "[[ -n $remote_host && $remote_host =~ ^[a-zA-Z0-9.-]+$ ]] || { echo 'Invalid remote host'; exit 1; }"
      },
      {
        "id": 6,
        "instruction": "Validate that the ssh_port variable, if provided, is a number between 1 and 65535.",
        "answer": "[[ -z $ssh_port || ($ssh_port -ge 1 && $ssh_port -le 65535) ]] || { echo 'Invalid SSH port'; exit 1; }"
      },
      {
        "id": 7,
        "instruction": "Validate that the private_key variable, if provided, points to an existing and readable file.",
        "answer": "[[ -z $private_key || -r $private_key ]] || { echo 'Private key file does not exist or is not readable'; exit 1; }"
      },
      {
        "id": 8,
        "instruction": "Set the default SSH port to 22 if the ssh_port variable is empty.",
        "answer": "ssh_port=${ssh_port:-22}"
      },
      {
        "id": 9,
        "instruction": "Construct the SSH command using the remote_host, ssh_user, ssh_port, and private_key variables. Include the private key option only if private_key is not empty.",
        "answer": "ssh_cmd=\"ssh -p $ssh_port ${private_key:+-i $private_key} $ssh_user@$remote_host\""
      },
      {
        "id": 10,
        "instruction": "Display the constructed SSH command in the terminal for user verification.",
        "answer": "echo \"SSH Command: $ssh_cmd\""
      },
      {
        "id": 11,
        "instruction": "Execute the constructed SSH command to connect to the remote server.",
        "answer": "eval $ssh_cmd"
      },
      {
        "id": 12,
        "instruction": "Handle errors by checking if the SSH command failed and displaying an error message.",
        "answer": "[[ $? -ne 0 ]] && echo 'SSH connection failed. Please check your inputs and try again.'"
      }
    ]
  },{
    "id": 22,
    "title": "On ServerA, log in as one user and optionally switch to another user, validating input and ensuring the users exist.",
    "steps": [
      {
        "id": 1,
        "instruction": "Create a prompt in the bash terminal that outputs 'Enter username to log in as: ' and stores the input in a variable named 'login_user'.",
        "answer": "read -p 'Enter username to log in as: ' login_user"
      },
      {
        "id": 2,
        "instruction": "Create a prompt in the bash terminal that outputs 'Do you want to switch to another user? (yes/no): ' and stores the input in a variable named 'switch_option'.",
        "answer": "read -p 'Do you want to switch to another user? (yes/no): ' switch_option"
      },
      {
        "id": 3,
        "instruction": "If the user chooses to switch (answer is 'yes'), create a prompt that outputs 'Enter target username: ' and stores the input in a variable named 'target_user'.",
        "answer": "if [[ $switch_option == 'yes' ]]; then read -p 'Enter target username: ' target_user; fi"
      },
      {
        "id": 4,
        "instruction": "Validate that the 'login_user' variable is not empty and that the specified user exists on the system. If the variable is empty or the user does not exist, display the message 'User does not exist or input is empty' and exit the script with a status code of 1.",
        "answer": "[[ -n $login_user && $(id -u $login_user 2>/dev/null) ]] || { echo 'User does not exist or input is empty'; exit 1; }"
      },
      {
        "id": 5,
        "instruction": "If switching is requested, validate that the 'target_user' variable is not empty and the specified user exists on the system. If the user does not exist or the input is empty, display the message 'Target user does not exist or input is empty' and exit the script with a status code of 1.",
        "answer": "[[ -z $target_user || $(id -u $target_user 2>/dev/null) ]] || { echo 'Target user does not exist or input is empty'; exit 1; }"
      },
      {
        "id": 6,
        "instruction": "Log in as the specified 'login_user' using the su command and display a success message if the command is successful.",
        "answer": "su - $login_user && echo 'Logged in as $login_user successfully.'"
      },
      {
        "id": 7,
        "instruction": "If switching is requested, switch to the 'target_user' from the logged-in session using the su command. Display the message 'Switched to $target_user successfully' if successful, or 'Failed to switch to $target_user' if it fails.",
        "answer": "if [[ $switch_option == 'yes' ]]; then su - $target_user && echo 'Switched to $target_user successfully' || echo 'Failed to switch to $target_user'; fi"
      }
    ]
  },{
    "id": 23,
    "title": "On ServerA, archive a directory, compress it using gzip, then decompress and extract it using user-specified inputs.",
    "steps": [
      {
        "id": 1,
        "instruction": "Prompt the user to enter the name of the directory to archive. Display the prompt 'Enter the directory to archive: ' and store the input in a variable named 'directory'.",
        "answer": "read -p 'Enter the directory to archive: ' directory"
      },
      {
        "id": 2,
        "instruction": "Prompt the user to enter the name for the tar archive. Display the prompt 'Enter the tar archive name (without extension): ' and store the input in a variable named 'archive_name'.",
        "answer": "read -p 'Enter the tar archive name (without extension): ' archive_name"
      },
      {
        "id": 3,
        "instruction": "Prompt the user to enter the name for the compressed file. Display the prompt 'Enter the name for the compressed file (without extension): ' and store the input in a variable named 'compressed_name'.",
        "answer": "read -p 'Enter the name for the compressed file (without extension): ' compressed_name"
      },
      {
        "id": 4,
        "instruction": "Validate that the 'directory' variable is not empty and that the directory exists. If it does not exist or is empty, display the message 'Directory does not exist or input is empty' and exit the script with a status code of 1.",
        "answer": "[[ -d $directory ]] || { echo 'Directory does not exist or input is empty'; exit 1; }"
      },
      {
        "id": 5,
        "instruction": "Validate that the 'archive_name' variable is not empty. If it is empty, display the message 'Archive name cannot be empty' and exit the script with a status code of 1.",
        "answer": "[[ -n $archive_name ]] || { echo 'Archive name cannot be empty'; exit 1; }"
      },
      {
        "id": 6,
        "instruction": "Validate that the 'compressed_name' variable is not empty. If it is empty, display the message 'Compressed file name cannot be empty' and exit the script with a status code of 1.",
        "answer": "[[ -n $compressed_name ]] || { echo 'Compressed file name cannot be empty'; exit 1; }"
      },
      {
        "id": 7,
        "instruction": "Create a tar archive of the specified directory. The archive should be named '${archive_name}.tar'.",
        "answer": "tar -cf ${archive_name}.tar $directory"
      },
      {
        "id": 8,
        "instruction": "Compress the tar archive using gzip. The compressed file should be referenced as '${compressed_name}.gz'.",
        "answer": "gzip -c ${archive_name}.tar > ${compressed_name}.gz"
      },
      {
        "id": 9,
        "instruction": "Decompress the compressed file using gzip. The decompressed tar file should be named '${archive_name}.tar'.",
        "answer": "gzip -d ${compressed_name}.gz"
      },
      {
        "id": 10,
        "instruction": "Extract the decompressed tar archive to the current directory. The extracted files should come from '${archive_name}.tar'.",
        "answer": "tar -xf ${archive_name}.tar"
      }
    ]
  },{
    "id": 24,
    "title": "On ServerA, create and edit a text file using user-specified methods and tools.",
    "steps": [
      {
        "id": 1,
        "instruction": "Prompt the user to enter the name of the text file they want to create. Store this input in a variable named 'file_name'.",
        "answer": "read -p 'Enter the name of the text file to create: ' file_name"
      },
      {
        "id": 2,
        "instruction": "Prompt the user to choose a method for creating the file: 'touch', 'cat', or 'echo'. Store this input in a variable named 'creation_method'.",
        "answer": "read -p 'Choose a method to create the file (touch, cat, echo): ' creation_method"
      },
      {
        "id": 3,
        "instruction": "Create the file using the method chosen by the user. If 'touch' is chosen, use 'touch $file_name'. If 'cat' is chosen, use 'cat > $file_name'. If 'echo' is chosen, use 'echo > $file_name'.",
        "answer": "case $creation_method in touch) touch $file_name ;; cat) cat > $file_name ;; echo) echo '' > $file_name ;; esac"
      },
      {
        "id": 4,
        "instruction": "Prompt the user to choose how they want to add content to the file: 'append' or 'overwrite'. Store this input in a variable named 'write_method'.",
        "answer": "read -p 'Do you want to append or overwrite the file? (append/overwrite): ' write_method"
      },
      {
        "id": 5,
        "instruction": "Based on the user's choice, add content to the file. If 'append' is chosen, use 'cat >> $file_name'. If 'overwrite' is chosen, use 'cat > $file_name'.",
        "answer": "case $write_method in append) cat >> $file_name ;; overwrite) cat > $file_name ;; esac"
      },
      {
        "id": 6,
        "instruction": "Prompt the user to choose a text editor to open the file: 'nano', 'vim', or 'gedit'. Store this input in a variable named 'editor'.",
        "answer": "read -p 'Choose a text editor to open the file (nano, vim, gedit): ' editor"
      },
      {
        "id": 7,
        "instruction": "Open the file using the selected text editor. If 'nano' is chosen, use 'nano $file_name'. If 'vim' is chosen, use 'vim $file_name'. If 'gedit' is chosen, use 'gedit $file_name'.",
        "answer": "case $editor in nano) nano $file_name ;; vim) vim $file_name ;; gedit) gedit $file_name ;; esac"
      }
    ]
  },{
    "id": 25,
    "title": "On ServerA, delete a file using the correct command.",
    "steps": [
      {
        "id": 1,
        "instruction": "Prompt the user to enter the file name. Store this input in a variable named 'file_name'.",
        "answer": "read -p 'Enter the file name to delete: ' file_name"
      },
      {
        "id": 2,
        "instruction": "Delete the file specified by the 'file_name' variable.",
        "answer": "rm $file_name"
      }
    ]
  },{
    "id": 26,
    "title": "On ServerA, delete an empty directory.",
    "steps": [
      {
        "id": 1,
        "instruction": "Prompt the user to enter the name of the empty directory they want to delete. Store this input in a variable named 'directory_name'.",
        "answer": "read -p 'Enter the empty directory name to delete: ' directory_name"
      },
      {
        "id": 2,
        "instruction": "Delete the directory specified by the 'directory_name' variable.",
        "answer": "rmdir $directory_name"
      }
    ]
  },{
    "id": 27,
    "title": "On ServerA, delete a directory and its contents.",
    "steps": [
      {
        "id": 1,
        "instruction": "Prompt the user to enter the name of the directory they want to delete. Store this input in a variable named 'directory_name'.",
        "answer": "read -p 'Enter the directory name to delete (including contents): ' directory_name"
      },
      {
        "id": 2,
        "instruction": "Delete the directory specified by the 'directory_name' variable along with all its contents.",
        "answer": "rm -r $directory_name"
      }
    ]
  }, {
      "id": 28,
      "title": "On ServerA, move a file to a new location.",
      "steps": [
        {
          "id": 1,
          "instruction": "Prompt the user to enter the source file path. Store this input in a variable named 'source_file'.",
          "answer": "read -p 'Enter the source file path: ' source_file"
        },
        {
          "id": 2,
          "instruction": "Prompt the user to enter the destination file path. Store this input in a variable named 'destination_file'.",
          "answer": "read -p 'Enter the destination file path: ' destination_file"
        },
        {
          "id": 3,
          "instruction": "Move the file from the source path to the destination path using the 'mv' command.",
          "answer": "mv $source_file $destination_file"
        }
      ]
    },
    {
      "id": 29,
      "title": "On ServerA, move a directory to a new location.",
      "steps": [
        {
          "id": 1,
          "instruction": "Prompt the user to enter the source directory path. Store this input in a variable named 'source_directory'.",
          "answer": "read -p 'Enter the source directory path: ' source_directory"
        },
        {
          "id": 2,
          "instruction": "Prompt the user to enter the destination directory path. Store this input in a variable named 'destination_directory'.",
          "answer": "read -p 'Enter the destination directory path: ' destination_directory"
        },
        {
          "id": 3,
          "instruction": "Move the directory from the source path to the destination path using the 'mv' command.",
          "answer": "mv $source_directory $destination_directory"
        }
      ]
    },
    {
      "id": 30,
      "title": "On ServerA, copy a file to a new location.",
      "steps": [
        {
          "id": 1,
          "instruction": "Prompt the user to enter the source file path. Store this input in a variable named 'source_file'.",
          "answer": "read -p 'Enter the source file path: ' source_file"
        },
        {
          "id": 2,
          "instruction": "Prompt the user to enter the destination file path. Store this input in a variable named 'destination_file'.",
          "answer": "read -p 'Enter the destination file path: ' destination_file"
        },
        {
          "id": 3,
          "instruction": "Copy the file from the source path to the destination path using the 'cp' command.",
          "answer": "cp $source_file $destination_file"
        }
      ]
    },
    {
      "id": 31,
      "title": "On ServerA, copy a directory and its contents to a new location.",
      "steps": [
        {
          "id": 1,
          "instruction": "Prompt the user to enter the source directory path. Store this input in a variable named 'source_directory'.",
          "answer": "read -p 'Enter the source directory path: ' source_directory"
        },
        {
          "id": 2,
          "instruction": "Prompt the user to enter the destination directory path. Store this input in a variable named 'destination_directory'.",
          "answer": "read -p 'Enter the destination directory path: ' destination_directory"
        },
        {
          "id": 3,
          "instruction": "Copy the directory and its contents from the source path to the destination path using the 'cp -r' command.",
          "answer": "cp -r $source_directory $destination_directory"
        }
      ]
    },{
      "id": 32,
      "title": "On ServerA, create hard or symbolic links for files based on user input.",
      "steps": [
        {
          "id": 1,
          "instruction": "Prompt the user to choose the type of link to create. Display the prompt 'Enter link type (hard/symbolic): ' and store the input in a variable named 'link_type'.",
          "answer": "read -p 'Enter link type (hard/symbolic): ' link_type"
        },
        {
          "id": 2,
          "instruction": "Prompt the user to enter the path of the target file. Display the prompt 'Enter the target file path: ' and store the input in a variable named 'target_file'.",
          "answer": "read -p 'Enter the target file path: ' target_file"
        },
        {
          "id": 3,
          "instruction": "Prompt the user to enter the name for the link to be created. Display the prompt 'Enter the name for the link: ' and store the input in a variable named 'link_name'.",
          "answer": "read -p 'Enter the name for the link: ' link_name"
        },
        {
          "id": 4,
          "instruction": "Check the value of 'link_type'. If it is 'hard', create a hard link. Display a success message 'Hard link created successfully' after creating the link.",
          "answer": "if [[ $link_type == 'hard' ]]; then ln $target_file $link_name && echo 'Hard link created successfully'; fi"
        },
        {
          "id": 5,
          "instruction": "If the value of 'link_type' is 'symbolic', create a symbolic link. Display a success message 'Symbolic link created successfully.' after creating the link.",
          "answer": "if [[ $link_type == 'symbolic' ]]; then ln -s $target_file $link_name && echo 'Symbolic link created successfully'; fi"
        },
        {
          "id": 6,
          "instruction": "If the value of 'link_type' is neither 'hard' nor 'symbolic', display an error message 'Invalid link type entered' and exit the script.",
          "answer": "if [[ $link_type != 'hard' && $link_type != 'symbolic' ]]; then echo 'Invalid link type entered'; exit 1; fi"
        }
      ]
    },{
      "id": 33,
      "title": "On ServerA, manage file and directory permissions using chmod.",
      "steps": [
        {
          "id": 1,
          "instruction": "List all files in the directory '/path/to/directory' along with their current permissions using the command 'ls -l /path/to/directory'. Replace '/path/to/directory' with the desired directory path.",
          "answer": "ls -l /path/to/directory"
        },
        {
          "id": 2,
          "instruction": "Prompt the user to enter the name of the file to change permissions to 755 by displaying the message: 'Enter the name of the file to change permissions to 755: '. Store the input in a variable named 'file1' and use the 'chmod' command to set the permissions.",
          "answer": "read -p 'Enter the name of the file to change permissions to 755: ' file1; chmod 755 $file1"
        },
        {
          "id": 3,
          "instruction": "Prompt the user to enter the name of the file to change permissions to 644 by displaying the message: 'Enter the name of the file to change permissions to 644: '. Store the input in a variable named 'file2' and use the 'chmod' command to set the permissions.",
          "answer": "read -p 'Enter the name of the file to change permissions to 644: ' file2; chmod 644 $file2"
        },
        {
          "id": 4,
          "instruction": "Prompt the user to enter the directory path to recursively set permissions to 600 by displaying the message: 'Enter the directory path to recursively set permissions to 600: '. Store the input in a variable named 'target_directory' and use the 'chmod -R' command to apply the permissions.",
          "answer": "read -p 'Enter the directory path to recursively set permissions to 600: ' target_directory; chmod -R 600 $target_directory"
        },
        {
          "id": 5,
          "instruction": "Create a new file named 'newfile' using the 'touch' command. Then, set its permissions to 700 using the 'chmod' command and verify the change by listing its permissions with 'ls -l newfile'.",
          "answer": "touch newfile; chmod 700 newfile; ls -l newfile"
        }
      ]
    },{
      "id": 34,
      "title": "On ServerA, configure autofs to automatically mount a network file system (NFS) when accessed.",
      "steps": [
        {
          "id": 1,
          "instruction": "Ensure the autofs package is installed on your system by using the package manager.",
          "answer": "sudo dnf install autofs -y"
        },
        {
          "id": 2,
          "instruction": "Edit the '/etc/auto.master' file to include a new map file for automount configuration. Add the following line to the file: '/mnt/nfs /etc/auto.nfs'.",
          "answer": "sudo bash -c \"echo '/mnt/nfs /etc/auto.nfs' >> /etc/auto.master\""
        },
        {
          "id": 3,
          "instruction": "Create the '/etc/auto.nfs' map file to specify the NFS server and share to mount. Add the following line to the file: 'share -rw,soft nfsserver:/export/share'. Replace 'nfsserver:/export/share' with the actual NFS server and export path.",
          "answer": "sudo bash -c \"echo 'share -rw,soft nfsserver:/export/share' > /etc/auto.nfs\""
        },
        {
          "id": 4,
          "instruction": "Reload the autofs service to apply the new configuration.",
          "answer": "sudo systemctl restart autofs"
        },
        {
          "id": 5,
          "instruction": "Verify that the NFS mount is automatically created when accessed. Navigate to '/mnt/nfs/share' to trigger the automount.",
          "answer": "cd /mnt/nfs/share"
        },
        {
          "id": 6,
          "instruction": "Confirm the mount by listing the active mounts and checking for the automounted directory.",
          "answer": "mount | grep autofs"
        }
      ]
    },{
      "id": 35,
      "title": "On ServerA, create a set-GID directory and configure its permissions for collaborative use.",
      "steps": [
        {
          "id": 1,
          "instruction": "Check that the script is called with two arguments: the directory name and the group name. If not, display the message 'Usage: script_name <directory_name> <group_name>' and exit the script with a status code of 1.",
          "answer": "if [[ $# -ne 2 ]]; then echo 'Usage: $0 <directory_name> <group_name>'; exit 1; fi"
        },
        {
          "id": 2,
          "instruction": "Assign the first argument to a variable named 'directory_name' and the second argument to a variable named 'group_name'.",
          "answer": "directory_name=$1; group_name=$2"
        },
        {
          "id": 3,
          "instruction": "Create the directory specified by 'directory_name' if it does not already exist.",
          "answer": "mkdir -p $directory_name"
        },
        {
          "id": 4,
          "instruction": "Change the group ownership of the directory to the group specified by 'group_name'.",
          "answer": "chgrp $group_name $directory_name"
        },
        {
          "id": 5,
          "instruction": "Set the set-GID bit on the directory to ensure new files inherit the group ownership of the directory.",
          "answer": "chmod g+s $directory_name"
        },
        {
          "id": 6,
          "instruction": "Verify and display the permissions of the directory to confirm the set-GID bit is set. Use the 'ls -ld' command.",
          "answer": "ls -ld $directory_name"
        }
      ]
    },{
      "id": 36,
      "title": "On ServerA, create and manage cron jobs for scheduled task automation.",
      "steps": [
        {
          "id": 1,
          "instruction": "List all existing cron jobs for the current user to view any scheduled tasks.",
          "answer": "crontab -l"
        },
        {
          "id": 2,
          "instruction": "Create or edit a cron job to schedule a script named 'backup.sh' to run daily at 2:30 AM. Use the 'crontab -e' command to edit the cron jobs.",
          "answer": "echo '30 2 * * * /path/to/backup.sh' | crontab -"
        },
        {
          "id": 3,
          "instruction": "Verify that the new cron job has been added by listing all cron jobs for the current user.",
          "answer": "crontab -l"
        },
        {
          "id": 4,
          "instruction": "Create a cron job to delete all log files in the '/var/log/tmp_logs' directory at 1:00 AM on the first day of each month. Use 'crontab -e' or an alternative command to add the job.",
          "answer": "echo '0 1 1 * * rm -rf /var/log/tmp_logs/*.log' | crontab -"
        },
        {
          "id": 5,
          "instruction": "Check the status of the cron service to ensure it is active and running.",
          "answer": "systemctl status crond"
        },
        {
          "id": 6,
          "instruction": "Start and enable the cron service if it is not already running.",
          "answer": "sudo systemctl start crond; sudo systemctl enable crond"
        },
        {
          "id": 7,
          "instruction": "Remove all cron jobs for the current user to reset the crontab.",
          "answer": "crontab -r"
        }
      ]
    },{
      "id": 37,
      "title": "On ServerA, manage a service by starting, stopping, enabling, disabling, and verifying its status.",
      "steps": [
        {
          "id": 1,
          "instruction": "Prompt the user to enter the name of the service to manage. Store the input in a variable named 'service_name'.",
          "answer": "read -p 'Enter the name of the service to manage: ' service_name"
        },
        {
          "id": 2,
          "instruction": "Start the specified service using the systemctl command.",
          "answer": "sudo systemctl start $service_name"
        },
        {
          "id": 3,
          "instruction": "Stop the specified service using the systemctl command.",
          "answer": "sudo systemctl stop $service_name"
        },
        {
          "id": 4,
          "instruction": "Enable the specified service to start automatically at boot using the systemctl command.",
          "answer": "sudo systemctl enable $service_name"
        },
        {
          "id": 5,
          "instruction": "Disable the specified service from starting automatically at boot using the systemctl command.",
          "answer": "sudo systemctl disable $service_name"
        },
        {
          "id": 6,
          "instruction": "Check the status of the specified service using the systemctl command and display its state.",
          "answer": "sudo systemctl status $service_name"
        }
      ]
    },{
      "id": 38,
      "title": "On ServerA, configure the system to boot into a specific target using systemd.",
      "steps": [
        {
          "id": 1,
          "instruction": "Prompt the user to enter the name of the target they want to set as the default (e.g., multi-user.target or graphical.target). Store the input in a variable named 'target'.",
          "answer": "read -p 'Enter the target to set as default (e.g., multi-user.target, graphical.target): ' target"
        },
        {
          "id": 2,
          "instruction": "Set the specified target as the default boot target using the systemctl command.",
          "answer": "sudo systemctl set-default $target"
        },
        {
          "id": 3,
          "instruction": "Verify that the default target has been set correctly by displaying the current default target.",
          "answer": "systemctl get-default"
        },
        {
          "id": 4,
          "instruction": "Display the status of all systemd targets to show their active states.",
          "answer": "systemctl list-units --type=target"
        }
      ]
    },{
      "id": 39,
      "title": "On ServerA, manage the GRUB bootloader by backing up the configuration, updating it, adding a custom entry, and setting the default boot entry.",
      "steps": [
        {
          "id": 1,
          "instruction": "Create a backup directory at '/backup/grub' if it does not already exist.",
          "answer": "sudo mkdir -p /backup/grub"
        },
        {
          "id": 2,
          "instruction": "Backup the current GRUB configuration file '/boot/grub2/grub.cfg' to the '/backup/grub' directory.",
          "answer": "sudo cp /boot/grub2/grub.cfg /backup/grub/"
        },
        {
          "id": 3,
          "instruction": "Update the GRUB configuration file to include any new kernels or changes using the grub2-mkconfig command.",
          "answer": "sudo grub2-mkconfig -o /boot/grub2/grub.cfg"
        },
        {
          "id": 4,
          "instruction": "Edit the '/etc/grub.d/40_custom' file to add a custom GRUB entry for a hypothetical custom kernel. Add the following lines:\n\nmenuentry 'Custom Kernel' {\n  set root='hd0,msdos1'\n  linux /vmlinuz-custom root=/dev/sda1 ro\n  initrd /initrd-custom.img\n}",
          "answer": "sudo vim /etc/grub.d/40_custom"
        },
        {
          "id": 5,
          "instruction": "Regenerate the GRUB configuration file to include the custom entry using the grub2-mkconfig command.",
          "answer": "sudo grub2-mkconfig -o /boot/grub2/grub.cfg"
        },
        {
          "id": 6,
          "instruction": "Set the default boot entry to the newly added custom kernel entry using the grub2-set-default command.",
          "answer": "sudo grub2-set-default 'Custom Kernel'"
        },
        {
          "id": 7,
          "instruction": "Verify the default boot entry to confirm it is set to the custom kernel.",
          "answer": "sudo grub2-editenv list"
        }
      ]
    },{
      "id": 40,
      "title": "On ServerA, configure hostname resolution by setting up DNS and updating the hosts file.",
      "steps": [
        {
          "id": 1,
          "instruction": "Prompt the user to enter the DNS server address. Display the message 'Enter the DNS server address: ' and store the input in a variable named 'dns_server'.",
          "answer": "read -p 'Enter the DNS server address: ' dns_server"
        },
        {
          "id": 2,
          "instruction": "Prompt the user to enter the search domain. Display the message 'Enter the search domain: ' and store the input in a variable named 'search_domain'.",
          "answer": "read -p 'Enter the search domain: ' search_domain"
        },
        {
          "id": 3,
          "instruction": "Create or update the '/etc/resolv.conf' file with the provided DNS server and search domain. Append 'nameserver' and 'search' lines to the file.",
          "answer": "echo -e 'nameserver $dns_server\\nsearch $search_domain' | sudo tee /etc/resolv.conf"
        },
        {
          "id": 4,
          "instruction": "Prompt the user to enter the hostname for the new hosts file entry. Display the message 'Enter the hostname: ' and store the input in a variable named 'hostname'.",
          "answer": "read -p 'Enter the hostname: ' hostname"
        },
        {
          "id": 5,
          "instruction": "Prompt the user to enter the IP address for the new hosts file entry. Display the message 'Enter the IP address: ' and store the input in a variable named 'ip_address'.",
          "answer": "read -p 'Enter the IP address: ' ip_address"
        },
        {
          "id": 6,
          "instruction": "Add the new entry to the '/etc/hosts' file using the provided hostname and IP address.",
          "answer": "echo '$ip_address $hostname' | sudo tee -a /etc/hosts"
        },
        {
          "id": 7,
          "instruction": "Verify that the DNS server is correctly set in '/etc/resolv.conf' by displaying the file's contents.",
          "answer": "cat /etc/resolv.conf"
        },
        {
          "id": 8,
          "instruction": "Verify that the new entry is present in '/etc/hosts' by displaying the file's contents.",
          "answer": "cat /etc/hosts"
        }
      ]
    },{
      "id": 41,
      "title": "On ServerA, manage firewall rules by adding, removing, listing, and checking the firewall status.",
      "steps": [
        {
          "id": 1,
          "instruction": "Prompt the user to enter a port number for which the firewall rule needs to be added. Display the message 'Enter the port number: ' and store the input in a variable named 'port'.",
          "answer": "read -p 'Enter the port number: ' port"
        },
        {
          "id": 2,
          "instruction": "Prompt the user to enter the firewall zone for the rule. Display the message 'Enter the firewall zone: ' and store the input in a variable named 'zone'.",
          "answer": "read -p 'Enter the firewall zone: ' zone"
        },
        {
          "id": 3,
          "instruction": "Add a firewall rule to allow traffic on the specified port and zone. Use the 'firewall-cmd' command with '--add-port' and '--permanent' options.",
          "answer": "sudo firewall-cmd --zone=$zone --add-port=$port/tcp --permanent"
        },
        {
          "id": 4,
          "instruction": "Prompt the user to enter a port number and zone to remove a firewall rule. Display the messages 'Enter the port number to remove: ' and 'Enter the firewall zone: ', storing inputs in variables 'port' and 'zone', respectively.",
          "answer": "read -p 'Enter the port number to remove: ' port; read -p 'Enter the firewall zone: ' zone"
        },
        {
          "id": 5,
          "instruction": "Remove the firewall rule for the specified port and zone using the 'firewall-cmd' command with '--remove-port' and '--permanent' options.",
          "answer": "sudo firewall-cmd --zone=$zone --remove-port=$port/tcp --permanent"
        },
        {
          "id": 6,
          "instruction": "Prompt the user to enter a firewall zone to list its current rules. Display the message 'Enter the firewall zone: ' and store the input in a variable named 'zone'.",
          "answer": "read -p 'Enter the firewall zone: ' zone"
        },
        {
          "id": 7,
          "instruction": "List all current firewall rules for the specified zone using the 'firewall-cmd' command with '--list-all'.",
          "answer": "sudo firewall-cmd --zone=$zone --list-all"
        },
        {
          "id": 8,
          "instruction": "Check the status of the firewall and display whether it is running. Use the 'firewall-cmd' command with '--state'.",
          "answer": "sudo firewall-cmd --state"
        },
        {
          "id": 9,
          "instruction": "Reload the firewall configuration to apply any changes. Use the 'firewall-cmd' command with '--reload'.",
          "answer": "sudo firewall-cmd --reload"
        }
      ]
    },{
      "id": 42,
      "title": "On ServerA, configure the firewall to allow HTTP and HTTPS traffic, block traffic on port 1234, and set the default zone to public.",
      "steps": [
        {
          "id": 1,
          "instruction": "Set the default firewall zone to 'public' using the 'firewall-cmd' command.",
          "answer": "sudo firewall-cmd --set-default-zone=public"
        },
        {
          "id": 2,
          "instruction": "Allow incoming HTTP traffic on port 80 in the 'public' zone. Use the '--add-service' option to specify the HTTP service and ensure the rule is persistent.",
          "answer": "sudo firewall-cmd --zone=public --add-service=http --permanent"
        },
        {
          "id": 3,
          "instruction": "Allow incoming HTTPS traffic on port 443 in the 'public' zone. Use the '--add-service' option to specify the HTTPS service and ensure the rule is persistent.",
          "answer": "sudo firewall-cmd --zone=public --add-service=https --permanent"
        },
        {
          "id": 4,
          "instruction": "Block incoming traffic on port 1234 in the 'public' zone. Use the '--add-rich-rule' option to define a rule that denies traffic on the specified port and ensure the rule is persistent.",
          "answer": "sudo firewall-cmd --zone=public --add-rich-rule='rule family=\"ipv4\" port protocol=\"tcp\" port=\"1234\" reject' --permanent"
        },
        {
          "id": 5,
          "instruction": "Reload the firewall configuration to apply all changes.",
          "answer": "sudo firewall-cmd --reload"
        },
        {
          "id": 6,
          "instruction": "Verify the default zone is set to 'public'. Use the 'firewall-cmd' command to check the current default zone.",
          "answer": "sudo firewall-cmd --get-default-zone"
        },
        {
          "id": 7,
          "instruction": "Verify that HTTP and HTTPS services are allowed in the 'public' zone. Use the 'firewall-cmd' command to list services in the zone.",
          "answer": "sudo firewall-cmd --zone=public --list-services"
        },
        {
          "id": 8,
          "instruction": "Verify that traffic on port 1234 is blocked in the 'public' zone. Use the 'firewall-cmd' command to list rich rules in the zone.",
          "answer": "sudo firewall-cmd --zone=public --list-rich-rules"
        }
      ]
    },{
      "id": 43,
      "title": "On ServerA, automate the setup of SSH key-based authentication for a remote server.",
      "steps": [
        {
          "id": 1,
          "instruction": "Check if an SSH key pair already exists by verifying the presence of the files '~/.ssh/id_rsa' and '~/.ssh/id_rsa.pub'. If they do not exist, prompt the user to confirm whether to generate a new key pair.",
          "answer": "if [[ ! -f ~/.ssh/id_rsa || ! -f ~/.ssh/id_rsa.pub ]]; then read -p 'SSH key pair not found. Generate a new key pair? (yes/no): ' confirm; if [[ $confirm == 'yes' ]]; then ssh-keygen -t rsa -b 2048 -N '' -f ~/.ssh/id_rsa; fi; fi"
        },
        {
          "id": 2,
          "instruction": "Prompt the user to enter the username and IP address of the remote server. Store the username in 'remote_user' and the IP address in 'remote_host'.",
          "answer": "read -p 'Enter the remote server username: ' remote_user; read -p 'Enter the remote server IP address: ' remote_host"
        },
        {
          "id": 3,
          "instruction": "Copy the public SSH key to the remote server using the 'ssh-copy-id' command.",
          "answer": "ssh-copy-id -i ~/.ssh/id_rsa.pub $remote_user@$remote_host"
        },
        {
          "id": 4,
          "instruction": "Verify that key-based authentication is working by attempting to log in to the remote server using SSH.",
          "answer": "ssh $remote_user@$remote_host"
        }
      ]
    },{
      "id": 44,
      "title": "On ServerA, manage SELinux modes for the current session using a shell script.",
      "steps": [
        {
          "id": 1,
          "instruction": "Check and display the current SELinux mode using the 'sestatus' command.",
          "answer": "sestatus | grep 'Current mode'"
        },
        {
          "id": 2,
          "instruction": "Store the current SELinux mode in a variable named 'current_mode' by using the 'getenforce' command.",
          "answer": "current_mode=$(getenforce)"
        },
        {
          "id": 3,
          "instruction": "Temporarily set SELinux to permissive mode using the 'setenforce' command.",
          "answer": "setenforce 0"
        },
        {
          "id": 4,
          "instruction": "Confirm that SELinux is now in permissive mode by re-checking the current mode using 'getenforce'.",
          "answer": "getenforce"
        },
        {
          "id": 5,
          "instruction": "Restore SELinux to its original mode stored in the 'current_mode' variable using the 'setenforce' command.",
          "answer": "setenforce $current_mode"
        },
        {
          "id": 6,
          "instruction": "Verify that SELinux has been restored to its original mode using the 'getenforce' command.",
          "answer": "getenforce"
        }
      ]
    },{
      "id": 45,
      "title": "On ServerA, manage and verify SELinux file contexts using a shell script.",
      "steps": [
        {
          "id": 1,
          "instruction": "List the SELinux contexts of all files in a specified directory.",
          "answer": "ls -Z /path/to/directory"
        },
        {
          "id": 2,
          "instruction": "Prompt the user to enter the directory path to list SELinux contexts of all files. Store this input in a variable named 'directory'.",
          "answer": "read -p 'Enter the directory path to list SELinux contexts: ' directory; ls -Z $directory"
        },
        {
          "id": 3,
          "instruction": "Prompt the user to enter the file path for which the SELinux context should be changed. Store this input in a variable named 'file_path'.",
          "answer": "read -p 'Enter the file path to change SELinux context: ' file_path"
        },
        {
          "id": 4,
          "instruction": "Prompt the user to enter the new SELinux context for the specified file. Store this input in a variable named 'new_context'.",
          "answer": "read -p 'Enter the new SELinux context: ' new_context"
        },
        {
          "id": 5,
          "instruction": "Change the SELinux context of the specified file to the new context.",
          "answer": "semanage fcontext -a -t $new_context $file_path; restorecon $file_path"
        },
        {
          "id": 6,
          "instruction": "Verify the SELinux context of the specified file after the change using the 'ls -Z' command.",
          "answer": "ls -Z $file_path"
        }
      ]
    },{
      "id": 46,
      "title": "On ServerA, restore default SELinux file contexts for a specified directory and its contents.",
      "steps": [
        {
          "id": 1,
          "instruction": "Prompt the user to enter the directory path for which SELinux contexts need to be restored. Store this input in a variable named 'directory'.",
          "answer": "read -p 'Enter the directory path to restore SELinux contexts: ' directory"
        },
        {
          "id": 2,
          "instruction": "Verify that the directory specified in the 'directory' variable exists. If it does not exist, display an error message and exit the script with a status code of 1.",
          "answer": "[[ -d $directory ]] || { echo 'Directory does not exist'; exit 1; }"
        },
        {
          "id": 3,
          "instruction": "Restore the default SELinux file contexts for the specified directory and its contents using the 'restorecon -R' command.",
          "answer": "restorecon -Rv $directory"
        },
        {
          "id": 4,
          "instruction": "Display the output of the restoration process, including any errors encountered, to the user.",
          "answer": "restorecon -Rv $directory"
        }
      ]
    },{
      "id": 47,
      "title": "On ServerA, manage SELinux port labels by adding and verifying a new label for a specific port.",
      "steps": [
        {
          "id": 1,
          "instruction": "Check if the 'semanage' command is available on the system. If not, output an error message and exit the script.",
          "answer": "command -v semanage >/dev/null 2>&1 || { echo 'Error: semanage command not found. Please install the policycoreutils-python-utils package.'; exit 1; }"
        },
        {
          "id": 2,
          "instruction": "Prompt the user to enter the port number they want to label. Store the input in a variable named 'port'.",
          "answer": "read -p 'Enter the port number to label: ' port"
        },
        {
          "id": 3,
          "instruction": "Prompt the user to enter the SELinux type for the port label (e.g., 'http_port_t'). Store the input in a variable named 'selinux_type'.",
          "answer": "read -p 'Enter the SELinux type for the port label (e.g., http_port_t): ' selinux_type"
        },
        {
          "id": 4,
          "instruction": "Add a new SELinux port label for the specified port and SELinux type using the 'semanage port -a' command.",
          "answer": "semanage port -a -t $selinux_type -p tcp $port"
        },
        {
          "id": 5,
          "instruction": "Verify that the new SELinux port label has been applied by listing all SELinux port labels and filtering for the specified port using 'semanage port -l'.",
          "answer": "semanage port -l | grep -w $port"
        }
      ]
    },{
      "id": 48,
      "title": "On ServerA, automate retrieving container images and handle errors with logging and notifications.",
      "steps": [
        {
          "id": 1,
          "instruction": "Prompt the user to enter the name of the container image, including the registry (e.g., 'docker.io/library/nginx'). Store the input in a variable named 'image_name'.",
          "answer": "read -p 'Enter the container image name (e.g., docker.io/library/nginx): ' image_name"
        },
        {
          "id": 2,
          "instruction": "Prompt the user to enter the tag of the container image (e.g., 'latest'). Store the input in a variable named 'image_tag'.",
          "answer": "read -p 'Enter the image tag (e.g., latest): ' image_tag"
        },
        {
          "id": 3,
          "instruction": "Attempt to pull the specified container image using 'podman pull' or 'docker pull'. Store the full image name with tag in a variable named 'full_image' and log the command's output to a file named 'image_pull.log'.",
          "answer": "full_image=\"$image_name:$image_tag\"; podman pull $full_image >> image_pull.log 2>&1 || docker pull $full_image >> image_pull.log 2>&1"
        },
        {
          "id": 4,
          "instruction": "Check if the container image pull command was successful. If it fails, log an error message to 'image_pull_error.log' and notify the user.",
          "answer": "[[ $? -ne 0 ]] && { echo \"Failed to pull $full_image\" | tee -a image_pull_error.log; exit 1; }"
        },
        {
          "id": 5,
          "instruction": "If the image pull is successful, log the success message to 'image_pull.log' and notify the user.",
          "answer": "echo \"Successfully pulled $full_image\" >> image_pull.log; echo \"Container image $full_image retrieved successfully.\""
        },
        {
          "id": 6,
          "instruction": "Optional: If email notification is enabled, send an email with the success or failure log. Use a tool like 'mail' and prompt the user for the recipient's email address. Store the email in a variable named 'email_recipient'.",
          "answer": "read -p 'Enter the email address for notifications: ' email_recipient; mail -s \"Container Image Pull Report\" $email_recipient < image_pull.log"
        }
      ]
    },{
      "id": 49,
      "title": "On ServerA, retrieve and inspect a container image, then parse its metadata for specific details.",
      "steps": [
        {
          "id": 1,
          "instruction": "Prompt the user to enter the name of the container image, including the registry (e.g., 'docker.io/library/nginx'). Store the input in a variable named 'image_name'.",
          "answer": "read -p 'Enter the container image name (e.g., docker.io/library/nginx): ' image_name"
        },
        {
          "id": 2,
          "instruction": "Pull the specified container image using 'podman pull' or 'docker pull'. Log the output to a file named 'image_retrieve.log'.",
          "answer": "podman pull $image_name >> image_retrieve.log 2>&1 || docker pull $image_name >> image_retrieve.log 2>&1"
        },
        {
          "id": 3,
          "instruction": "Check if the container image pull command was successful. If it fails, log an error message to 'image_retrieve_error.log' and exit the script with a status code of 1.",
          "answer": "[[ $? -ne 0 ]] && { echo \"Failed to pull $image_name\" | tee -a image_retrieve_error.log; exit 1; }"
        },
        {
          "id": 4,
          "instruction": "Inspect the pulled container image to retrieve metadata. Use the appropriate inspect command ('podman inspect' or 'docker inspect') and save the output to 'image_metadata.json'.",
          "answer": "podman inspect $image_name > image_metadata.json || docker inspect $image_name > image_metadata.json"
        },
        {
          "id": 5,
          "instruction": "Parse the metadata file 'image_metadata.json' to extract the image ID, creation date, and size. Use tools like 'jq' to process the JSON file.",
          "answer": "jq '.[0] | {ImageID: .Id, CreationDate: .Created, Size: .Size}' image_metadata.json"
        },
        {
          "id": 6,
          "instruction": "Check if the size of the container image exceeds 100MB. Print a message if the condition is met.",
          "answer": "size=$(jq -r '.[0].Size' image_metadata.json); [[ $size -gt 104857600 ]] && echo \"The image size is greater than 100MB: $((size / 1024 / 1024)) MB\""
        }
      ]
    },{
      "id": 50,
      "title": "On ServerA, manage container images by pulling, inspecting, pushing to another registry, and cleaning up.",
      "steps": [
        {
          "id": 1,
          "instruction": "Prompt the user to enter the name of the container image to pull (e.g., 'docker.io/library/nginx'). Store the input in a variable named 'image_name'.",
          "answer": "read -p 'Enter the container image name to pull (e.g., docker.io/library/nginx): ' image_name"
        },
        {
          "id": 2,
          "instruction": "Pull the specified container image using 'podman pull' and log the output to a file named 'image_pull.log'.",
          "answer": "podman pull $image_name >> image_pull.log 2>&1"
        },
        {
          "id": 3,
          "instruction": "Inspect the pulled container image using 'podman inspect' and save the metadata to a file named 'image_metadata.json'.",
          "answer": "podman inspect $image_name > image_metadata.json"
        },
        {
          "id": 4,
          "instruction": "Prompt the user to enter the destination registry for pushing the container image (e.g., 'quay.io/username/nginx'). Store the input in a variable named 'destination_image'.",
          "answer": "read -p 'Enter the destination registry and image name (e.g., quay.io/username/nginx): ' destination_image"
        },
        {
          "id": 5,
          "instruction": "Use skopeo to copy the container image from the local Podman repository to the specified remote registry.",
          "answer": "skopeo copy containers-storage:$image_name docker://$destination_image"
        },
        {
          "id": 6,
          "instruction": "Remove the local copy of the container image using 'podman rmi' to clean up.",
          "answer": "podman rmi $image_name"
        }
      ]
    },{
      "id": 51,
      "title": "On ServerA, manage a container by pulling an image, creating, starting, stopping, and removing it using podman or docker.",
      "steps": [
        {
          "id": 1,
          "instruction": "Prompt the user to enter the container image to pull (e.g., 'nginx'). Store the input in a variable named 'image_name'.",
          "answer": "read -p 'Enter the container image name to pull (e.g., nginx): ' image_name"
        },
        {
          "id": 2,
          "instruction": "Pull the specified container image from a public registry using 'podman pull' or 'docker pull'. Log the output to a file named 'container_pull.log'.",
          "answer": "podman pull $image_name >> container_pull.log 2>&1 || { echo 'Error: Failed to pull the image'; exit 1; }"
        },
        {
          "id": 3,
          "instruction": "Create and start a container from the pulled image. Prompt the user to name the container and store the input in a variable named 'container_name'.",
          "answer": "read -p 'Enter a name for the container: ' container_name; podman run -d --name $container_name $image_name || { echo 'Error: Failed to start the container'; exit 1; }"
        },
        {
          "id": 4,
          "instruction": "List all running containers to verify that the newly created container is running.",
          "answer": "podman ps"
        },
        {
          "id": 5,
          "instruction": "Stop the running container. Use the variable 'container_name' to specify the container.",
          "answer": "podman stop $container_name || { echo 'Error: Failed to stop the container'; exit 1; }"
        },
        {
          "id": 6,
          "instruction": "Remove the stopped container using the variable 'container_name'.",
          "answer": "podman rm $container_name || { echo 'Error: Failed to remove the container'; exit 1; }"
        }
      ]
    },{
      "id": 52,
      "title": "On ServerA, deploy an nginx web server inside a container and manage its lifecycle.",
      "steps": [
        {
          "id": 1,
          "instruction": "Pull the latest nginx image from the container registry. Use the 'podman pull' or 'docker pull' command to retrieve the image.",
          "answer": "podman pull nginx || { echo 'Error: Failed to pull nginx image'; exit 1; }"
        },
        {
          "id": 2,
          "instruction": "Run a new container with the nginx image. Ensure the container runs in the background and maps port 80 of the container to port 8080 on the host. Name the container 'nginx_server'.",
          "answer": "podman run -d --name nginx_server -p 8080:80 nginx || { echo 'Error: Failed to start nginx container'; exit 1; }"
        },
        {
          "id": 3,
          "instruction": "Verify that the nginx container is running by listing all running containers.",
          "answer": "podman ps"
        },
        {
          "id": 4,
          "instruction": "Test if the nginx service is accessible by navigating to http://localhost:8080 in a browser or using the curl command.",
          "answer": "curl http://localhost:8080"
        },
        {
          "id": 5,
          "instruction": "Stop the running nginx container using its name 'nginx_server'.",
          "answer": "podman stop nginx_server || { echo 'Error: Failed to stop nginx container'; exit 1; }"
        },
        {
          "id": 6,
          "instruction": "Remove the stopped nginx container using its name 'nginx_server'.",
          "answer": "podman rm nginx_server || { echo 'Error: Failed to remove nginx container'; exit 1; }"
        }
      ]
    },{
      "id": 53,
      "title": "On ServerA, configure a container as a systemd service using Podman.",
      "steps": [
        {
          "id": 1,
          "instruction": "Verify that the 'myapp:latest' container image is available locally. If it is not available, pull it using Podman.",
          "answer": "podman images | grep myapp || podman pull myapp:latest"
        },
        {
          "id": 2,
          "instruction": "Create a systemd service unit file named 'myapp.service' in the '/etc/systemd/system/' directory.",
          "answer": "sudo touch /etc/systemd/system/myapp.service"
        },
        {
          "id": 3,
          "instruction": "Edit the 'myapp.service' file to define the service. Add the following content to specify the container image, command, restart policy, and dependencies:",
          "answer": "[Unit]\nDescription=Podman container for MyApp\nWants=network-online.target\nAfter=network-online.target\n\n[Service]\nExecStart=/usr/bin/podman run --rm --name myapp -d myapp:latest\nExecStop=/usr/bin/podman stop myapp\nRestart=always\nRestartSec=10\n\n[Install]\nWantedBy=multi-user.target"
        },
        {
          "id": 4,
          "instruction": "Reload the systemd configuration to recognize the new service file.",
          "answer": "sudo systemctl daemon-reload"
        },
        {
          "id": 5,
          "instruction": "Enable the 'myapp' service to start automatically on system boot.",
          "answer": "sudo systemctl enable myapp.service"
        },
        {
          "id": 6,
          "instruction": "Start the 'myapp' service immediately.",
          "answer": "sudo systemctl start myapp.service"
        },
        {
          "id": 7,
          "instruction": "Verify the status of the 'myapp' service to ensure it is running correctly.",
          "answer": "sudo systemctl status myapp.service"
        }
      ]
    },{
      "id": 54,
      "title": "On ServerA, configure persistent storage for a Podman container.",
      "steps": [
        {
          "id": 1,
          "instruction": "Create a directory on the host to be used as persistent storage. Prompt the user to enter the directory path and store it in a variable named 'host_dir'.",
          "answer": "read -p 'Enter the host directory path for persistent storage: ' host_dir; mkdir -p $host_dir"
        },
        {
          "id": 2,
          "instruction": "Run a Podman container with the host directory mounted as a volume. Prompt the user to enter the container name, image name, and volume mount point inside the container.",
          "answer": "read -p 'Enter the container name: ' container_name; read -p 'Enter the container image name: ' image_name; read -p 'Enter the container volume mount point (e.g., /data): ' container_mount; podman run -d --name $container_name -v $host_dir:$container_mount $image_name"
        },
        {
          "id": 3,
          "instruction": "Verify that the volume is correctly mounted inside the container by listing the contents of the mount point. Use the 'podman exec' command.",
          "answer": "podman exec $container_name ls -l $container_mount"
        },
        {
          "id": 4,
          "instruction": "Write a test file to the mounted volume from inside the container. Use the 'podman exec' command to create a file named 'test_file.txt' inside the container's mount point.",
          "answer": "podman exec $container_name sh -c 'echo \"Test File Content\" > $container_mount/test_file.txt'"
        },
        {
          "id": 5,
          "instruction": "Stop the container using the 'podman stop' command.",
          "answer": "podman stop $container_name"
        },
        {
          "id": 6,
          "instruction": "Verify that the test file exists in the host directory after the container is stopped by listing the contents of the host directory.",
          "answer": "ls -l $host_dir"
        }
      ]
    },{
      "id": 55,
      "title": "On ServerA, manage software packages using yum, dnf, and rpm for package management.",
      "steps": [
        {
          "id": 1,
          "instruction": "List all installed packages using `yum` and save the output to a file named `installed_packages_yum.txt`.",
          "answer": "yum list installed > installed_packages_yum.txt"
        },
        {
          "id": 2,
          "instruction": "Use `dnf` to search for a package named `nano` and display the available versions.",
          "answer": "dnf search nano"
        },
        {
          "id": 3,
          "instruction": "Install the latest version of the `nano` text editor using `dnf`.",
          "answer": "sudo dnf install nano"
        },
        {
          "id": 4,
          "instruction": "Verify that `nano` has been installed by querying the package using `rpm`.",
          "answer": "rpm -q nano"
        },
        {
          "id": 5,
          "instruction": "Display detailed information about the `nano` package using `rpm`.",
          "answer": "rpm -qi nano"
        },
        {
          "id": 6,
          "instruction": "List all files installed by the `nano` package using `rpm`.",
          "answer": "rpm -ql nano"
        },
        {
          "id": 7,
          "instruction": "Remove the `nano` package using `dnf`.",
          "answer": "sudo dnf remove nano"
        },
        {
          "id": 8,
          "instruction": "Check for updates to installed packages and list available updates using `dnf`.",
          "answer": "dnf check-update"
        },
        {
          "id": 9,
          "instruction": "Update all installed packages to their latest versions using `dnf`.",
          "answer": "sudo dnf upgrade"
        },
        {
          "id": 10,
          "instruction": "Download the `vim` package RPM file without installing it using `dnf`.",
          "answer": "dnf download vim"
        },
        {
          "id": 11,
          "instruction": "Install the downloaded `vim` RPM file using `rpm`.",
          "answer": "sudo rpm -ivh vim-*.rpm"
        },
        {
          "id": 12,
          "instruction": "Remove the `vim` package using `rpm`.",
          "answer": "sudo rpm -e vim"
        },
        {
          "id": 13,
          "instruction": "Reinstall the `vim` package using `dnf`.",
          "answer": "sudo dnf reinstall vim"
        },
        {
          "id": 14,
          "instruction": "Enable the Extra Packages for Enterprise Linux (EPEL) repository using `dnf`.",
          "answer": "sudo dnf install epel-release"
        },
        {
          "id": 15,
          "instruction": "Install the `htop` package from the EPEL repository using `dnf`.",
          "answer": "sudo dnf install htop"
        },
        {
          "id": 16,
          "instruction": "Disable the EPEL repository temporarily when installing a package using `dnf`.",
          "answer": "sudo dnf install --disablerepo=epel <package_name>"
        },
        {
          "id": 17,
          "instruction": "Clean the package cache using `dnf`.",
          "answer": "sudo dnf clean all"
        },
        {
          "id": 18,
          "instruction": "List all enabled repositories using `dnf`.",
          "answer": "dnf repolist enabled"
        },
        {
          "id": 19,
          "instruction": "Display package group information using `yum`.",
          "answer": "yum group list"
        },
        {
          "id": 20,
          "instruction": "Install the 'Development Tools' package group using `yum`.",
          "answer": "sudo yum groupinstall 'Development Tools'"
        }
      ]
    },{
      "id": 56,
      "title": "Configuring SSH and Key-Based Authentication: Securing SSH access on ServerA.",
      "steps": [
        {
          "id": 1,
          "instruction": "Ensure the SSH service is installed and running on ServerA. Install the service if it is not already installed.",
          "answer": "sudo dnf install -y openssh-server && sudo systemctl enable --now sshd"
        },
        {
          "id": 2,
          "instruction": "Create a new user named `secureuser` for secure SSH access.",
          "answer": "sudo useradd secureuser"
        },
        {
          "id": 3,
          "instruction": "On the client machine, generate an SSH key pair using the `ssh-keygen` command. Save the key to a file named `id_rsa_secureuser`.",
          "answer": "ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa_secureuser"
        },
        {
          "id": 4,
          "instruction": "Copy the public key to `secureuser`'s home directory on ServerA using the `ssh-copy-id` command.",
          "answer": "ssh-copy-id -i ~/.ssh/id_rsa_secureuser.pub secureuser@ServerA"
        },
        {
          "id": 5,
          "instruction": "Manually verify that the public key has been added to the `~/.ssh/authorized_keys` file on ServerA for `secureuser`.",
          "answer": "cat /home/secureuser/.ssh/authorized_keys"
        },
        {
          "id": 6,
          "instruction": "Test key-based authentication by logging in as `secureuser` to ServerA without a password.",
          "answer": "ssh -i ~/.ssh/id_rsa_secureuser secureuser@ServerA"
        },
        {
          "id": 7,
          "instruction": "On ServerA, disable password-based authentication in the SSH configuration file.",
          "answer": "sudo sed -i 's/^#PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config"
        },
        {
          "id": 8,
          "instruction": "Restrict SSH access to the `secureuser` account by editing the SSH configuration file.",
          "answer": "echo 'AllowUsers secureuser' | sudo tee -a /etc/ssh/sshd_config"
        },
        {
          "id": 9,
          "instruction": "Change the default SSH port to 2222 to reduce unauthorized access attempts.",
          "answer": "sudo sed -i 's/^#Port 22/Port 2222/' /etc/ssh/sshd_config"
        },
        {
          "id": 10,
          "instruction": "Restart the SSH service to apply the new configuration.",
          "answer": "sudo systemctl restart sshd"
        },
        {
          "id": 11,
          "instruction": "On the client machine, test the new configuration by connecting to ServerA using the key and the new port.",
          "answer": "ssh -i ~/.ssh/id_rsa_secureuser -p 2222 secureuser@ServerA"
        },
        {
          "id": 12,
          "instruction": "Enable SSH connection logging for auditing purposes on ServerA.",
          "answer": "sudo sed -i 's/^#LogLevel INFO/LogLevel VERBOSE/' /etc/ssh/sshd_config && sudo systemctl restart sshd"
        },
        {
          "id": 13,
          "instruction": "Set a login banner to warn unauthorized users by editing the SSH configuration file.",
          "answer": "echo 'Banner /etc/issue.net' | sudo tee -a /etc/ssh/sshd_config && echo 'Unauthorized access is prohibited!' | sudo tee /etc/issue.net"
        },
        {
          "id": 14,
          "instruction": "Restrict SSH access to specific IP ranges by configuring the firewall on ServerA.",
          "answer": "sudo firewall-cmd --permanent --add-rich-rule='rule family=\"ipv4\" source address=\"192.168.1.0/24\" service name=\"ssh\" accept' && sudo firewall-cmd --reload"
        },
        {
          "id": 15,
          "instruction": "Test the restricted IP access by attempting to connect from an unauthorized IP address.",
          "answer": "ssh -i ~/.ssh/id_rsa_secureuser secureuser@ServerA -p 2222 (Should fail if from unauthorized IP)"
        },
        {
          "id": 16,
          "instruction": "Verify that SSH logins are being logged in `/var/log/secure`.",
          "answer": "sudo tail /var/log/secure"
        },
        {
          "id": 17,
          "instruction": "Create a backup of the SSH configuration file for future reference.",
          "answer": "sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak"
        }
      ]
    },{
      "id": 57,
      "title": "Process Management: Monitoring and Controlling System Processes",
      "steps": [
        {
          "id": 1,
          "instruction": "List all running processes in the system, including processes of other users, in a hierarchical format.",
          "answer": "ps -eF --forest"
        },
        {
          "id": 2,
          "instruction": "Use the `top` command to display real-time process information. Explore the available sorting options.",
          "answer": "top (then use `M` to sort by memory usage or `P` to sort by CPU usage)"
        },
        {
          "id": 3,
          "instruction": "Display detailed information about a specific process using its PID. Assume the PID is `1234`.",
          "answer": "ps -p 1234 -o pid,ppid,cmd,%mem,%cpu,stat"
        },
        {
          "id": 4,
          "instruction": "Kill a process with PID `5678` using the `kill` command.",
          "answer": "kill 5678"
        },
        {
          "id": 5,
          "instruction": "Kill a process forcefully using `SIGKILL` if it does not respond to the normal kill command.",
          "answer": "kill -9 5678"
        },
        {
          "id": 6,
          "instruction": "Find and kill a process by its name, such as `firefox`.",
          "answer": "pkill firefox"
        },
        {
          "id": 7,
          "instruction": "Start a long-running process, such as `sleep 600`, in the background and verify it is running.",
          "answer": "sleep 600 & && jobs"
        },
        {
          "id": 8,
          "instruction": "Bring the `sleep` process started in the background to the foreground.",
          "answer": "fg %1"
        },
        {
          "id": 9,
          "instruction": "Suspend the `sleep` process running in the foreground.",
          "answer": "Ctrl+Z"
        },
        {
          "id": 10,
          "instruction": "Resume the `sleep` process in the background.",
          "answer": "bg %1"
        },
        {
          "id": 11,
          "instruction": "Change the priority of a running process with PID `91011` to a higher priority (lower nice value).",
          "answer": "sudo renice -5 -p 91011"
        },
        {
          "id": 12,
          "instruction": "Monitor process resource usage, including CPU and memory usage, with a command-line utility.",
          "answer": "htop"
        },
        {
          "id": 13,
          "instruction": "Write a script to check if a process named `httpd` is running. If not, start the service.",
          "answer": "if ! pgrep httpd; then sudo systemctl start httpd; fi"
        },
        {
          "id": 14,
          "instruction": "Use the `strace` command to trace system calls made by a process with PID `121314`.",
          "answer": "strace -p 121314"
        },
        {
          "id": 15,
          "instruction": "Monitor a specific user's processes in real-time using a command-line utility.",
          "answer": "top -u <username>"
        },
        {
          "id": 16,
          "instruction": "Create a cron job to check the number of running processes every minute and log it to a file.",
          "answer": "echo '* * * * * ps -e | wc -l >> /var/log/process_count.log' | crontab -"
        },
        {
          "id": 17,
          "instruction": "Identify zombie processes on the system and explain their significance.",
          "answer": "ps aux | awk '$8 == \"Z\" { print $2, $11 }' (Zombie processes are defunct processes that have completed execution but still have an entry in the process table because their parent has not read their exit status.)"
        }
      ]
    },{
      "id": 58,
      "title": "System Logging: Understanding and Managing Log Files",
      "steps": [
        {
          "id": 1,
          "instruction": "View the last 20 lines of the system log file `/var/log/syslog` (or `/var/log/messages` depending on your distribution).",
          "answer": "tail -n 20 /var/log/syslog"
        },
        {
          "id": 2,
          "instruction": "Continuously monitor a log file to view new entries in real time.",
          "answer": "tail -f /var/log/syslog"
        },
        {
          "id": 3,
          "instruction": "List all log files managed by the `journald` service.",
          "answer": "journalctl --list-boots"
        },
        {
          "id": 4,
          "instruction": "Display all logs for the current boot using `journalctl`.",
          "answer": "journalctl -b"
        },
        {
          "id": 5,
          "instruction": "Filter system logs to show only messages related to the `sshd` service.",
          "answer": "journalctl -u sshd"
        },
        {
          "id": 6,
          "instruction": "Configure log rotation for the `/var/log/syslog` file to manage its size.",
          "answer": "Edit `/etc/logrotate.d/rsyslog` to specify rotation frequency, size, and retention."
        },
        {
          "id": 7,
          "instruction": "Write a script to check the size of `/var/log/syslog`. If it exceeds 50MB, archive it with a timestamp.",
          "answer": "if [ $(stat -c%s /var/log/syslog) -gt $((50 * 1024 * 1024)) ]; then cp /var/log/syslog /var/log/syslog.$(date +%Y%m%d%H%M%S); > /var/log/syslog; fi"
        },
        {
          "id": 8,
          "instruction": "Clear the contents of the `/var/log/auth.log` file without deleting it.",
          "answer": "> /var/log/auth.log"
        },
        {
          "id": 9,
          "instruction": "Configure `rsyslog` to forward all logs to a remote server with the IP `192.168.1.100`.",
          "answer": "Edit `/etc/rsyslog.conf` and add `*.* @192.168.1.100:514`."
        },
        {
          "id": 10,
          "instruction": "Find and display all `ERROR` messages from `/var/log/syslog`.",
          "answer": "grep 'ERROR' /var/log/syslog"
        }
      ]
    },{
      "id": 59,
      "title": "Kernel Modules: Loading and Configuring Kernel Modules",
      "steps": [
        {
          "id": 1,
          "instruction": "List all currently loaded kernel modules.",
          "answer": "lsmod"
        },
        {
          "id": 2,
          "instruction": "Display detailed information about the `dm_mod` module.",
          "answer": "modinfo dm_mod"
        },
        {
          "id": 3,
          "instruction": "Load the `loop` kernel module manually.",
          "answer": "sudo modprobe loop"
        },
        {
          "id": 4,
          "instruction": "Remove the `loop` module from the kernel.",
          "answer": "sudo modprobe -r loop"
        },
        {
          "id": 5,
          "instruction": "Load a module named `example.ko` from the `/tmp` directory.",
          "answer": "sudo insmod /tmp/example.ko"
        },
        {
          "id": 6,
          "instruction": "Remove the `example` module loaded with `insmod`.",
          "answer": "sudo rmmod example"
        },
        {
          "id": 7,
          "instruction": "List all dependencies of the `firewire_core` kernel module.",
          "answer": "modinfo -F depends firewire_core"
        },
        {
          "id": 8,
          "instruction": "Blacklist the `nouveau` kernel module to prevent it from loading during boot.",
          "answer": "Add `blacklist nouveau` to `/etc/modprobe.d/blacklist.conf`."
        },
        {
          "id": 9,
          "instruction": "Verify that the `nouveau` module is not loaded after blacklisting.",
          "answer": "lsmod | grep nouveau"
        },
        {
          "id": 10,
          "instruction": "Write a script to check if the `ext4` module is loaded and load it if necessary.",
          "answer": "if ! lsmod | grep ext4; then sudo modprobe ext4; fi"
        },
        {
          "id": 11,
          "instruction": "Create a persistent configuration to load the `br_netfilter` module on every boot.",
          "answer": "Add `br_netfilter` to `/etc/modules-load.d/br_netfilter.conf`."
        },
        {
          "id": 12,
          "instruction": "Monitor kernel messages in real-time to verify module loading using `dmesg`.",
          "answer": "dmesg -w"
        }
      ]
    },{
      "id": 60,
      "title": "Configuring Password Aging Policies",
      "steps": [
        {
          "id": 1,
          "instruction": "Display the current password aging information for a user named 'alice'.",
          "answer": "chage -l alice"
        },
        {
          "id": 2,
          "instruction": "Set the maximum number of days a password remains valid before it must be changed (e.g., 60 days) for the user 'alice'.",
          "answer": "sudo chage -M 60 alice"
        },
        {
          "id": 3,
          "instruction": "Set the minimum number of days before a password can be changed (e.g., 7 days) for the user 'alice'.",
          "answer": "sudo chage -m 7 alice"
        },
        {
          "id": 4,
          "instruction": "Set the number of days of warning before a password expires (e.g., 7 days) for the user 'alice'.",
          "answer": "sudo chage -W 7 alice"
        },
        {
          "id": 5,
          "instruction": "Set the account to expire 90 days after the password is changed for the user 'alice'.",
          "answer": "sudo chage -I 90 alice"
        },
        {
          "id": 6,
          "instruction": "Verify the updated password aging information for 'alice'.",
          "answer": "chage -l alice"
        },
        {
          "id": 7,
          "instruction": "Set default password aging policies for all new users by editing the '/etc/login.defs' file. Set 'PASS_MAX_DAYS' to 60, 'PASS_MIN_DAYS' to 7, and 'PASS_WARN_AGE' to 7.",
          "answer": "Edit the file '/etc/login.defs' using 'sudo vim /etc/login.defs' and set 'PASS_MAX_DAYS 60', 'PASS_MIN_DAYS 7', and 'PASS_WARN_AGE 7'."
        },
        {
          "id": 8,
          "instruction": "Create a new user named 'bob' and verify that the default password aging policies have been applied.",
          "answer": "Run 'sudo useradd bob', set the password with 'sudo passwd bob', and verify the policies using 'chage -l bob'."
        },
        {
          "id": 9,
          "instruction": "Force the user 'alice' to change her password on the next login.",
          "answer": "sudo chage -d 0 alice"
        },
        {
          "id": 10,
          "instruction": "Lock the account of the user 'charlie' to prevent any login.",
          "answer": "sudo usermod -L charlie"
        },
        {
          "id": 11,
          "instruction": "Unlock the account of the user 'charlie' to allow login.",
          "answer": "sudo usermod -U charlie"
        },
        {
          "id": 12,
          "instruction": "Set an account expiration date for the user 'diana' to December 31, 2024.",
          "answer": "sudo chage -E 2024-12-31 diana"
        },
        {
          "id": 13,
          "instruction": "Disable password expiration for the user 'eve' to prevent the password from expiring.",
          "answer": "sudo chage -M -1 eve"
        }
      ]
    },{
      "id": 61,
      "title": "Configuring Encrypted Partitions and Using cryptsetup",
      "steps": [
        {
          "id": 1,
          "instruction": "List the available partitions on the system to identify the target partition for encryption.",
          "answer": "lsblk"
        },
        {
          "id": 2,
          "instruction": "Initialize the selected partition '/dev/sdX1' for encryption using `cryptsetup`. Confirm the action when prompted.",
          "answer": "sudo cryptsetup luksFormat /dev/sdX1"
        },
        {
          "id": 3,
          "instruction": "Open the encrypted partition and map it to a device named 'secure_partition'.",
          "answer": "sudo cryptsetup open /dev/sdX1 secure_partition"
        },
        {
          "id": 4,
          "instruction": "Create a new ext4 file system on the mapped device '/dev/mapper/secure_partition'.",
          "answer": "sudo mkfs.ext4 /dev/mapper/secure_partition"
        },
        {
          "id": 5,
          "instruction": "Create a mount point at '/mnt/secure' and mount the encrypted partition to this location.",
          "answer": "Run 'sudo mkdir /mnt/secure' and 'sudo mount /dev/mapper/secure_partition /mnt/secure'."
        },
        {
          "id": 6,
          "instruction": "Verify the partition is mounted successfully by listing the contents of the mount point.",
          "answer": "ls /mnt/secure"
        },
        {
          "id": 7,
          "instruction": "Unmount the partition and close the encrypted device.",
          "answer": "Run 'sudo umount /mnt/secure' and 'sudo cryptsetup close secure_partition'."
        },
        {
          "id": 8,
          "instruction": "Add an entry to '/etc/crypttab' to enable unlocking the encrypted partition on boot. Map '/dev/sdX1' to 'secure_partition'.",
          "answer": "Run 'sudo vim /etc/crypttab' and add 'secure_partition /dev/sdX1 none luks'."
        },
        {
          "id": 9,
          "instruction": "Add an entry to '/etc/fstab' to mount the encrypted partition at '/mnt/secure' after unlocking during boot.",
          "answer": "Run 'sudo vim /etc/fstab' and add '/dev/mapper/secure_partition /mnt/secure ext4 defaults 0 2'."
        },
        {
          "id": 10,
          "instruction": "Reboot the system and verify the encrypted partition is automatically unlocked and mounted at '/mnt/secure'.",
          "answer": "ls /mnt/secure"
        }
      ]
    },{
      "id": 62,
      "title": "Managing Stratis and VDO Storage",
      "steps": [
        {
          "id": 1,
          "instruction": "Install the required packages for Stratis and VDO storage management.",
          "answer": "Run 'sudo dnf install stratisd stratis-cli vdo kmod-kvdo'."
        },
        {
          "id": 2,
          "instruction": "Enable and start the Stratis daemon service.",
          "answer": "Run 'sudo systemctl enable stratisd && sudo systemctl start stratisd'."
        },
        {
          "id": 3,
          "instruction": "Create a new Stratis pool named 'mypool' using the device '/dev/sdX'.",
          "answer": "sudo stratis pool create mypool /dev/sdX"
        },
        {
          "id": 4,
          "instruction": "Create a Stratis filesystem named 'myfs' within the 'mypool'.",
          "answer": "sudo stratis filesystem create mypool myfs"
        },
        {
          "id": 5,
          "instruction": "Mount the Stratis filesystem at '/mnt/stratis'.",
          "answer": "Run 'sudo mkdir /mnt/stratis && sudo mount /stratis/mypool/myfs /mnt/stratis'."
        },
        {
          "id": 6,
          "instruction": "Verify that the Stratis filesystem is mounted successfully.",
          "answer": "ls /mnt/stratis"
        },
        {
          "id": 7,
          "instruction": "Create a VDO volume named 'myvdo' with 10 GB of physical size on '/dev/sdX'.",
          "answer": "sudo vdo create --name=myvdo --device=/dev/sdX --vdoLogicalSize=10G"
        },
        {
          "id": 8,
          "instruction": "Verify the VDO volume status to ensure it is active.",
          "answer": "sudo vdostats --human-readable"
        },
        {
          "id": 9,
          "instruction": "Format the VDO volume with an ext4 filesystem.",
          "answer": "sudo mkfs.ext4 /dev/mapper/myvdo"
        },
        {
          "id": 10,
          "instruction": "Create a mount point at '/mnt/vdo' and mount the VDO volume.",
          "answer": "Run 'sudo mkdir /mnt/vdo && sudo mount /dev/mapper/myvdo /mnt/vdo'."
        },
        {
          "id": 11,
          "instruction": "Add entries to '/etc/fstab' to ensure the Stratis and VDO volumes are mounted on boot.",
          "answer": "Run 'sudo vim /etc/fstab' and add '/stratis/mypool/myfs /mnt/stratis xfs defaults 0 0' and '/dev/mapper/myvdo /mnt/vdo ext4 defaults 0 0'."
        },
        {
          "id": 12,
          "instruction": "Reboot the system and verify that both the Stratis and VDO volumes are automatically mounted.",
          "answer": "Run 'ls /mnt/stratis' and 'ls /mnt/vdo' to verify."
        },
        {
          "id": 13,
          "instruction": "Resize the Stratis pool 'mypool' by adding another device '/dev/sdY'.",
          "answer": "Run 'sudo stratis pool add-data mypool /dev/sdY'."
        },
        {
          "id": 14,
          "instruction": "Enable deduplication and compression for the VDO volume 'myvdo'.",
          "answer": "Run 'sudo vdo enableCompression /dev/mapper/myvdo && sudo vdo enableDeduplication /dev/mapper/myvdo'."
        },
        {
          "id": 15,
          "instruction": "Delete the Stratis pool 'mypool' and clean up its configuration.",
          "answer": "Run 'sudo umount /mnt/stratis && sudo stratis filesystem destroy mypool myfs && sudo stratis pool destroy mypool'."
        },
        {
          "id": 16,
          "instruction": "Delete the VDO volume 'myvdo' and clean up its configuration.",
          "answer": "Run 'sudo umount /mnt/vdo && sudo vdo remove --name=myvdo'."
        }        
      ]
    },{
      "id": 63,
      "title": "Understanding and Using Dracut for Rebuilding initramfs",
      "steps": [
        {
          "id": 1,
          "instruction": "List the available initramfs files on the system to identify the current configuration.",
          "answer": "ls -l /boot/initramfs-*"
        },
        {
          "id": 2,
          "instruction": "Inspect the current kernel version to ensure compatibility when rebuilding initramfs.",
          "answer": "uname -r"
        },
        {
          "id": 3,
          "instruction": "Back up the existing initramfs file before making any changes.",
          "answer": "sudo cp /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r).img.bak"
        },
        {
          "id": 4,
          "instruction": "Rebuild the initramfs file for the currently running kernel using dracut.",
          "answer": "sudo dracut -f /boot/initramfs-$(uname -r).img $(uname -r)"
        },
        {
          "id": 5,
          "instruction": "Generate a new initramfs file for a specific kernel version (e.g., '5.15.0').",
          "answer": "sudo dracut -f /boot/initramfs-5.15.0.img 5.15.0"
        },
        {
          "id": 6,
          "instruction": "Verify the contents of the newly created initramfs file.",
          "answer": "lsinitrd /boot/initramfs-$(uname -r).img"
        },
        {
          "id": 7,
          "instruction": "Troubleshoot by adding verbose output during the initramfs rebuild process.",
          "answer": "sudo dracut -fv /boot/initramfs-$(uname -r).img $(uname -r)"
        },
        {
          "id": 8,
          "instruction": "Reboot the system to test the newly rebuilt initramfs.",
          "answer": "sudo reboot"
        },
        {
          "id": 9,
          "instruction": "If the system fails to boot, use a live CD/USB to access the system and rebuild initramfs.",
          "answer": "Boot into a live environment, mount the root filesystem with 'sudo mount /dev/sdXn /mnt', chroot with 'sudo chroot /mnt', rebuild initramfs with 'sudo dracut -f /boot/initramfs-$(uname -r).img $(uname -r)', exit chroot, and reboot."
        },
        {
          "id": 10,
          "instruction": "Restore the backed-up initramfs file if issues persist after rebuilding.",
          "answer": "sudo mv /boot/initramfs-$(uname -r).img.bak /boot/initramfs-$(uname -r).img"
        }
      ]
    },{
      "id": 64,
      "title": "Using Tools for System Monitoring: vmstat, iostat, sar, and dmesg",
      "steps": [
        {
          "id": 1,
          "instruction": "Display basic system performance statistics such as CPU, memory, and I/O using `vmstat`.",
          "answer": "vmstat 1 5"
        },
        {
          "id": 2,
          "instruction": "View detailed statistics about block device I/O using `iostat`.",
          "answer": "iostat -x 2 3"
        },
        {
          "id": 3,
          "instruction": "Check the overall system load and memory usage using `sar` from the sysstat package.",
          "answer": "sar -r 1 5"
        },
        {
          "id": 4,
          "instruction": "Inspect kernel messages related to hardware or driver errors using `dmesg`.",
          "answer": "dmesg | tail"
        },
        {
          "id": 5,
          "instruction": "Monitor CPU usage over time with `sar`.",
          "answer": "sar -u 1 5"
        },
        {
          "id": 6,
          "instruction": "List disk usage by device using `iostat` with human-readable output.",
          "answer": "iostat -h"
        },
        {
          "id": 7,
          "instruction": "Filter `dmesg` output for messages related to a specific driver or hardware, such as 'eth0'.",
          "answer": "dmesg | grep eth0"
        },
        {
          "id": 8,
          "instruction": "Install the sysstat package to enable the use of `sar` if it's not available.",
          "answer": "sudo yum install sysstat"
        },{
          "id": 9,
          "instruction": "Enable and start the sysstat service to collect performance statistics regularly.",
          "answer": "sudo systemctl enable sysstat && sudo systemctl start sysstat"
        },
        {
          "id": 10,
          "instruction": "Analyze CPU and I/O usage trends for the past day using `sar`.",
          "answer": "sar -q -f /var/log/sa/sa$(date +%d)"
        },
        {
          "id": 11,
          "instruction": "Combine `vmstat` and `sar` to correlate memory and CPU usage trends.",
          "answer": "vmstat 1 10 > memory_usage.txt && sar -u 1 10 > cpu_usage.txt && echo 'Review memory_usage.txt and cpu_usage.txt to analyze trends.'"
        },
        {
          "id": 12,
          "instruction": "Run `dmesg` with timestamps for easier debugging of kernel messages.",
          "answer": "dmesg -T"
        },
        {
          "id": 13,
          "instruction": "Check CPU, memory, and I/O usage using a combined tool such as `htop` for real-time monitoring.",
          "answer": "sudo htop"
        },
        {
          "id": 14,
          "instruction": "Schedule regular reports from `sar` using a cron job.",
          "answer": "sudo bash -c \"echo '0 * * * * /usr/lib64/sa/sa1' >> /var/spool/cron/root\""
        },
        {
          "id": 15,
          "instruction": "Filter `vmstat` output to focus on memory usage only.",
          "answer": "vmstat -s | grep -i memory"
        }        
      ]
    },{
      "id": 65,
      "title": "One-Time Task Scheduling",
      "steps": [
        {
          "id": 1,
          "instruction": "Schedule a one-time task to display 'Hello, World!' after 5 minutes using `at`.",
          "answer": "echo 'echo Hello, World!' | at now + 5 minutes"
        },
        {
          "id": 2,
          "instruction": "Verify the list of scheduled tasks created with `at`.",
          "answer": "atq"
        },
        {
          "id": 3,
          "instruction": "Remove a specific job from the `at` queue by its job number (e.g., job number 2).",
          "answer": "atrm 2"
        },
        {
          "id": 4,
          "instruction": "Check if the `at` service is active and enable it if necessary.",
          "answer": "sudo systemctl status atd && sudo systemctl enable --now atd"
        },
        {
          "id": 5,
          "instruction": "Schedule a task to reboot the system at a specific time (e.g., 02:00 AM).",
          "answer": "echo 'sudo reboot' | at 02:00"
        },
        {
          "id": 6,
          "instruction": "Schedule a one-time task to create a backup file after 10 minutes using `at`.",
          "answer": "echo 'cp /path/to/file /path/to/backup' | at now + 10 minutes"
        },
        {
          "id": 7,
          "instruction": "Display the contents of a scheduled `at` job by its job number (e.g., job number 1).",
          "answer": "at -c 1"
        },
        {
          "id": 8,
          "instruction": "Schedule a task to display the current date in a file after 15 minutes.",
          "answer": "echo 'date > /tmp/current_date.txt' | at now + 15 minutes"
        },
        {
          "id": 9,
          "instruction": "Configure a user to be allowed to use `at` by editing the `/etc/at.allow` file.",
          "answer": "sudo sh -c 'echo \"username\" >> /etc/at.allow'"
        },
        {
          "id": 10,
          "instruction": "Check the logs to confirm if a scheduled `at` job ran successfully.",
          "answer": "sudo journalctl -u atd"
        }        
      ]
    },{
        "id": 66,
        "title": "View a file's contents using `cat` and navigate through it with `less`.",
        "steps": [
          {
            "id": 1,
            "instruction": "Prompt the user to enter the name of the file to view using `cat`. Store the input in a variable named 'file_name'.",
            "answer": "read -p 'Enter the name of the file to view: ' file_name"
          },
          {
            "id": 2,
            "instruction": "Use the `cat` command to display the file's contents.",
            "answer": "cat $file_name"
          },
          {
            "id": 3,
            "instruction": "Open the same file in `less` for navigation.",
            "answer": "less $file_name"
          },
          {
            "id": 4,
            "instruction": "Exit the `less` viewer by pressing 'q'.",
            "answer": "Press 'q' to exit."
          }
        ]
      },
      {
        "id": 67,
        "title": "Extract and display specific lines from a file using `head` and `tail`.",
        "steps": [
          {
            "id": 1,
            "instruction": "Prompt the user to enter the name of the file to view specific lines from. Store the input in a variable named 'file_name'.",
            "answer": "read -p 'Enter the name of the file: ' file_name"
          },
          {
            "id": 2,
            "instruction": "Display the first 10 lines of the file using `head`.",
            "answer": "head $file_name"
          },
          {
            "id": 3,
            "instruction": "Display the last 5 lines of the file using `tail`.",
            "answer": "tail -n 5 $file_name"
          },
          {
            "id": 4,
            "instruction": "Prompt the user to enter the number of lines from the start of the file to view. Store this input in a variable named 'line_count'.",
            "answer": "read -p 'Enter the number of lines to view from the start: ' line_count; head -n $line_count $file_name"
          }
        ]
      },
      {
        "id": 68,
        "title": "Search for a specific keyword in a file using `grep`.",
        "steps": [
          {
            "id": 1,
            "instruction": "Prompt the user to enter the file name and store it in a variable named 'file_name'.",
            "answer": "read -p 'Enter the file name: ' file_name"
          },
          {
            "id": 2,
            "instruction": "Prompt the user to enter a keyword to search for and store it in a variable named 'keyword'.",
            "answer": "read -p 'Enter the keyword to search for: ' keyword"
          },
          {
            "id": 3,
            "instruction": "Search the file for the keyword using `grep`.",
            "answer": "grep \"$keyword\" $file_name"
          },
          {
            "id": 4,
            "instruction": "Count the number of occurrences of the keyword in the file using `grep`.",
            "answer": "grep -c \"$keyword\" $file_name"
          }
        ]
      },
      {
        "id": 69,
        "title": "Filter and display specific fields from a file using `awk`.",
        "steps": [
          {
            "id": 1,
            "instruction": "Prompt the user to enter the name of the file to process. Store the input in a variable named 'file_name'.",
            "answer": "read -p 'Enter the name of the file: ' file_name"
          },
          {
            "id": 2,
            "instruction": "Prompt the user to enter the field number to display (assuming the file is space-delimited). Store this input in a variable named 'field_number'.",
            "answer": "read -p 'Enter the field number to display: ' field_number"
          },
          {
            "id": 3,
            "instruction": "Use `awk` to extract and display the specified field from the file.",
            "answer": "awk '{print $field_number}' $file_name"
          }
        ]
      },
      {
        "id": 70,
        "title": "Replace text in a file using `sed`.",
        "steps": [
          {
            "id": 1,
            "instruction": "Prompt the user to enter the file name. Store the input in a variable named 'file_name'.",
            "answer": "read -p 'Enter the file name: ' file_name"
          },
          {
            "id": 2,
            "instruction": "Prompt the user to enter the text to search for. Store this input in a variable named 'search_text'.",
            "answer": "read -p 'Enter the text to search for: ' search_text"
          },
          {
            "id": 3,
            "instruction": "Prompt the user to enter the replacement text. Store this input in a variable named 'replacement_text'.",
            "answer": "read -p 'Enter the replacement text: ' replacement_text"
          },
          {
            "id": 4,
            "instruction": "Use `sed` to replace all occurrences of the search text with the replacement text in the file. Save the output to a new file named 'output_file'.",
            "answer": "sed 's/$search_text/$replacement_text/g' $file_name > output_file"
          }
        ]
      },
      {
        "id": 71,
        "title": "Analyze and extract logs using a combination of `grep`, `awk`, and `sed`.",
        "steps": [
          {
            "id": 1,
            "instruction": "Prompt the user to enter the log file name. Store the input in a variable named 'log_file'.",
            "answer": "read -p 'Enter the log file name: ' log_file"
          },
          {
            "id": 2,
            "instruction": "Prompt the user to enter the log level to search for (e.g., INFO, ERROR). Store the input in a variable named 'log_level'.",
            "answer": "read -p 'Enter the log level to search for (e.g., INFO, ERROR): ' log_level"
          },
          {
            "id": 3,
            "instruction": "Use `grep` to extract all lines with the specified log level.",
            "answer": "grep \"$log_level\" $log_file"
          },
          {
            "id": 4,
            "instruction": "Use `awk` to extract and display the timestamp and log message from the extracted lines.",
            "answer": "grep \"$log_level\" $log_file | awk '{print $1, $2, $3, $4}'"
          },
          {
            "id": 5,
            "instruction": "Use `sed` to replace the log level with '[LOG]'.",
            "answer": "grep \"$log_level\" $log_file | sed 's/$log_level/[LOG]/g'"
          }
        ]
      }, {
        "id": 72,
        "title": "Repair a corrupted XFS filesystem using `xfs_repair`.",
        "steps": [
          {
            "id": 1,
            "instruction": "Prompt the user to enter the name of the XFS device to repair (e.g., /dev/sdb1). Store the input in a variable named 'device_name'.",
            "answer": "read -p 'Enter the XFS device to repair: ' device_name"
          },
          {
            "id": 2,
            "instruction": "Ensure the device is unmounted. If the device is mounted, unmount it using the `umount` command.",
            "answer": "umount $device_name"
          },
          {
            "id": 3,
            "instruction": "Run `xfs_repair` on the specified device to repair the filesystem.",
            "answer": "xfs_repair $device_name"
          },
          {
            "id": 4,
            "instruction": "If `xfs_repair` reports a need to mount the device for log recovery, mount the device and immediately unmount it, then re-run `xfs_repair`.",
            "answer": "mount $device_name && umount $device_name && xfs_repair $device_name"
          },
          {
            "id": 5,
            "instruction": "Display the device's status using `blkid` to ensure the repair was successful.",
            "answer": "blkid $device_name"
          }
        ]
      },
      {
        "id": 73,
        "title": "Expand an XFS filesystem using `xfs_growfs`.",
        "steps": [
          {
            "id": 1,
            "instruction": "Prompt the user to enter the mount point of the XFS filesystem to expand (e.g., /mnt/data). Store the input in a variable named 'mount_point'.",
            "answer": "read -p 'Enter the mount point of the XFS filesystem to expand: ' mount_point"
          },
          {
            "id": 2,
            "instruction": "Ensure the filesystem is mounted. If not, mount the filesystem to the specified mount point.",
            "answer": "mount | grep $mount_point || mount /dev/sdX1 $mount_point"
          },
          {
            "id": 3,
            "instruction": "Prompt the user to enter the new size or specify 'max' to grow the filesystem to use all available space. Store the input in a variable named 'new_size'.",
            "answer": "read -p 'Enter the new size for the filesystem (or type max for full expansion): ' new_size"
          },
          {
            "id": 4,
            "instruction": "Run `xfs_growfs` on the mount point to expand the filesystem. If 'max' is specified, omit the size parameter.",
            "answer": "if [[ $new_size == 'max' ]]; then xfs_growfs $mount_point; else xfs_growfs $mount_point -D $new_size; fi"
          },
          {
            "id": 5,
            "instruction": "Verify the expansion by checking the filesystem's size with the `df -h` command.",
            "answer": "df -h $mount_point"
          }
        ]
      },
      {
        "id": 74,
        "title": "Check the integrity of an XFS filesystem before repair.",
        "steps": [
          {
            "id": 1,
            "instruction": "Prompt the user to enter the device name of the XFS filesystem (e.g., /dev/sdb1). Store the input in a variable named 'device_name'.",
            "answer": "read -p 'Enter the XFS device to check: ' device_name"
          },
          {
            "id": 2,
            "instruction": "Run `xfs_check` to inspect the filesystem for errors. (If unavailable, advise using `xfs_repair` in dry-run mode.)",
            "answer": "xfs_check $device_name || echo 'xfs_check unavailable, consider dry-run repair with xfs_repair -n $device_name'"
          },
          {
            "id": 3,
            "instruction": "If errors are found, prompt the user to decide whether to proceed with repair.",
            "answer": "read -p 'Errors found. Proceed with repair? (yes/no): ' proceed && [[ $proceed == 'yes' ]] && xfs_repair $device_name"
          }
        ]
      },
      {
        "id": 75,
        "title": "Simulate a dry-run repair with `xfs_repair -n`.",
        "steps": [
          {
            "id": 1,
            "instruction": "Prompt the user to enter the device name of the XFS filesystem (e.g., /dev/sdb1). Store the input in a variable named 'device_name'.",
            "answer": "read -p 'Enter the XFS device to simulate repair: ' device_name"
          },
          {
            "id": 2,
            "instruction": "Run `xfs_repair` in dry-run mode to check for errors without making changes.",
            "answer": "xfs_repair -n $device_name"
          },
          {
            "id": 3,
            "instruction": "Interpret the output and decide if full repair is needed.",
            "answer": "echo 'Review output for errors and decide on further action.'"
          }
        ]
      },
      {
        "id": 76,
        "title": "Recover an XFS log manually before repair.",
        "steps": [
          {
            "id": 1,
            "instruction": "Prompt the user to enter the device name of the XFS filesystem (e.g., /dev/sdb1). Store the input in a variable named 'device_name'.",
            "answer": "read -p 'Enter the XFS device for log recovery: ' device_name"
          },
          {
            "id": 2,
            "instruction": "Mount the device to trigger automatic log recovery by the XFS kernel module.",
            "answer": "mount $device_name /mnt"
          },
          {
            "id": 3,
            "instruction": "Unmount the device once the log recovery is complete.",
            "answer": "umount $device_name"
          },
          {
            "id": 4,
            "instruction": "Run `xfs_repair` on the device if log recovery was not successful.",
            "answer": "xfs_repair $device_name"
          }
        ]
      },
      {
        "id": 77,
        "title": "Resize an underlying block device and grow the XFS filesystem.",
        "steps": [
          {
            "id": 1,
            "instruction": "Expand the underlying block device (e.g., resize a virtual disk or add space to a partition).",
            "answer": "Follow steps for resizing the block device using your hypervisor or partition tool."
          },
          {
            "id": 2,
            "instruction": "Run `partprobe` to inform the kernel of the changes to the block device.",
            "answer": "partprobe"
          },
          {
            "id": 3,
            "instruction": "Run `xfs_growfs` on the mounted XFS filesystem to use the newly available space.",
            "answer": "xfs_growfs /mnt"
          },
          {
            "id": 4,
            "instruction": "Verify the expansion by checking the filesystem's size with `df -h`.",
            "answer": "df -h /mnt"
          }
        ]
      },
      {
        "id": 78,
        "title": "Setting and Modifying ACLs using setfacl and getfacl",
        "steps": [
          {
            "id": 1,
            "instruction": "Prompt the user to enter the file or directory name to manage ACLs and store it in a variable named 'file_name'.",
            "answer": "read -p 'Enter the file or directory name to manage ACLs: ' file_name"
          },
          {
            "id": 2,
            "instruction": "Display the current ACLs for the specified file or directory using getfacl.",
            "answer": "getfacl $file_name"
          },
          {
            "id": 3,
            "instruction": "Prompt the user to enter a username and permissions (e.g., rwx) to set an ACL for the user. Store the inputs in variables 'username' and 'permissions'.",
            "answer": "read -p 'Enter the username: ' username; read -p 'Enter the permissions (e.g., rwx): ' permissions"
          },
          {
            "id": 4,
            "instruction": "Set the specified ACL for the user on the given file or directory using setfacl.",
            "answer": "setfacl -m u:$username:$permissions $file_name"
          },
          {
            "id": 5,
            "instruction": "Prompt the user to enter a group name and permissions to set an ACL for the group. Store the inputs in variables 'groupname' and 'permissions'.",
            "answer": "read -p 'Enter the group name: ' groupname; read -p 'Enter the permissions (e.g., rwx): ' permissions"
          },
          {
            "id": 6,
            "instruction": "Set the specified ACL for the group on the given file or directory using setfacl.",
            "answer": "setfacl -m g:$groupname:$permissions $file_name"
          },
          {
            "id": 7,
            "instruction": "Prompt the user to enter a default ACL for all files in a directory (if applicable). Store the inputs in variables 'default_permissions'.",
            "answer": "read -p 'Enter the default permissions for the directory (e.g., rwx): ' default_permissions"
          },
          {
            "id": 8,
            "instruction": "Set the default ACL for all files in a directory using setfacl.",
            "answer": "setfacl -d -m u:$username:$default_permissions $file_name"
          },
          {
            "id": 9,
            "instruction": "Remove an ACL entry for a specific user. Prompt the user to enter the username and store it in a variable 'username'.",
            "answer": "read -p 'Enter the username to remove ACL for: ' username; setfacl -x u:$username $file_name"
          },
          {
            "id": 10,
            "instruction": "Verify the updated ACLs for the specified file or directory.",
            "answer": "getfacl $file_name"
          }
        ]
      }
      
    ]
    

